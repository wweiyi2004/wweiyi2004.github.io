[{"title":"为美好的世界献上祝福","url":"/2025/07/10/为美好的世界献上祝福/","content":"\n为美好的世界献上祝福\n","categories":["漫评"]},{"title":"【回忆录】到信息学一游","url":"/2025/07/09/到信息学一游/","content":"\n# 【回忆录】到信息学一游\n\n## 序章\n\n现在是2025年7月份的一个晚上，是大二的暑假，大学生活已然过半，我终于通过一个自己参照教程的方式配置好了属于自己的博客，兴致满满。在添加友情链接的时候，我想起了我在初三的时候就已经了解到的学长 $Dew$ 和 $wjyyy$ ，于是找到他们的博客。在他们的博客中，其中置顶的就是他们的回忆录，也就是参加信息学竞赛的整个高中的心路历程，让我不由自主想起了自己的信息学竞赛的生活，有感而发，于是我也准备写一个自己的回忆录。如果说沙子写字，风轻轻一吹就能吹散，纸上面写字，稍微的烈火焚烧就能让踪迹悄然而逝，也许，写在网上，这份记忆才不会消失，成为一种永生的纪念（大概是有区块链？）。\n\n高中的生活，说累也累，说苦也苦，但是不知为什么，我总是不由自主回忆起高中的生活，回忆起那段信息学竞赛的日子，这大概是我人生中最特殊的经历之一。我不知道它对我的生活产生了多少的影响，然而它的确是不可缺少的。\n\n## 第一章 自前而后的延续\n\n我并不类似于 $Dew$ 和 $wjyyy$ 学长一样，是从高中开始学的信息学竞赛，我开始学信息学竞赛是在初一的时候。那个时候的我刚从小学升上来，小学执行的是素质教育，因此每周都会有社团活动时间，我对计算机有兴趣，便参加了计算机相关社团，学习了许多计算机的基础知识，比如word、ppt、Excel、VB以及Scratch的使用，算是对编程有了初步的了解。其实我一开始并不打算学习信息学竞赛，而是想学VB，做着自己喜欢的程序，对\n","categories":["游记"]},{"title":"wweiyi-first-blog","url":"/2025/07/08/wweiyi-first-blog/","content":"\n今天我重新创建了我的hexo驱动的blog，希望以后这个blog能够时常更新吧\n\n"},{"title":"【解题报告】 POJ3614 防晒","url":"/2019/08/09/【解题报告】-POJ3614-防晒/","content":"\n# 【解题报告】 POJ3614 防晒\n\n## 题目：[防晒](https://www.acwing.com/problem/content/112/)（已翻译）\n\n### 解题思路：\n\n模拟+贪心；\n\n我们这道题是一道好的贪心的例题，我们只要对于每一头奶牛按照它们的minspf进行递减排序，然后在对于每一种防晒霜进行一次扫描，找出符合条件的spf值最大的防晒霜\n\n但是会想到一点，我们需要将每一头奶牛的minspf和maxspf进行一一对应，所以我们可以使用结构体，然后自己在写一个比较函数，就可以让这两个数值一一对应，这样就方便多了\n\nAC代码\n\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int maxn=2505;\nint c,l,ans;\nstruct cow\n{\n\tint minspf;\n\tint maxspf;\n}a[maxn];\nstruct sc\n{\n\tint spf;\n\tint cover;\n}b[maxn];\nint cmp(sc a,sc b)\n{\n    if(a.spf==b.spf)\n    return a.cover>b.cover;\n    return a.spf>b.spf;\n}\nint cmp2(cow a,cow b)\n{\n    if(a.minspf==b.minspf)\n    return a.maxspf>b.maxspf;\n    return a.minspf>b.minspf;\n}\nint main()\n{\n\tcin>>c>>l;\n\tfor(int i=1;i<=c;i++)\n\tcin>>a[i].minspf>>a[i].maxspf;\n\tsort(a+1,a+1+c,cmp2);\n\tfor(int i=1;i<=l;i++)\n\tcin>>b[i].spf>>b[i].cover;\n\tsort(b+1,b+1+l,cmp);\n\tfor(int i=1;i<=c;i++)\n\t{\n\t\tfor(int j=1;j<=l;j++)\n\t\t{\n\t\t\tif(b[j].spf>=a[i].minspf&&b[j].spf<=a[i].maxspf&&b[j].cover)\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t\tb[j].cover--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n```\n","categories":["OI时期解题报告"]},{"title":"【解题报告】 天才ACM","url":"/2019/08/09/【解题报告】-天才ACM/","content":"\n# 【解题报告】 天才ACM\n\n## 题目：[天才ACM](https://www.acwing.com/problem/content/111/)\n\n### 解题思路：\n\n倍增算法\n\n设p=1，r=l\n\n求出r—r+p这一区间的校验值，如果校验值小于等于t，则r+=p，p*=2；\n\n否则p/=2;\n\n一直重复，直到p等于0的时候，r就是最终答案\n\nAC代码\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int maxn=500005;\nlong long t,tot;\nlong long n,m,k;\nlong long p[maxn];\nlong long f[maxn];\nint l,r,mid,j;\nlong long min(long long a,long long b)\n{\n\treturn a<b? a:b;\n}\nbool check(int l,int r) \n{\n    tot=0;\n    long long sum=0;\n    for(int i=l;i<=r;i++) \n\tf[++tot]=p[i];\n    sort(f+1,f+1+tot);\n    for(int i=1;i<=m;i++) \n\t{\n        if (i>=(tot-i+1)) \n\t\tbreak;\n        sum+=(long long)(f[tot-i+1]-f[i])*(f[tot-i+1]-f[i]);\n        if(sum>k)\n\t\tbreak;\n    }\n    if(sum>k)\n\treturn false;\n    return true;\n}\nbool cmp(int x,int y)\n{\n\treturn p[x]<p[y];\n}\nbool calc()\n{\n\tlong long sum=0;\n\tint ll=1,rr=tot;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\twhile(ll<rr&&f[ll]>mid)\n\t\tll++;\n\t\twhile(ll<rr&&f[rr]>mid)\n\t\trr--;\n\t\tif(ll>=rr)\n\t\tbreak;\n\t\tsum+=(long long)(p[f[rr]]-p[f[ll]])*(p[f[rr]]-p[f[ll]]);\n\t\tif(sum>k)\n\t\tbreak;\n\t\tll++;\n\t\trr--;\n\t}\n\treturn sum<=k;\n}\nvoid work()\n{\n\t\tcin>>n>>m>>k;\n\t\tfor(int i=1;i<=n;i++)\n\t\tcin>>p[i];\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;i+(1<<j)-1<=n;j++)\n\t\t\t{\n\t\t\t\tif(!check(i,i+(1<<j)-1))\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl=i+(1<<(j-1))-1;\n\t\t\tr=min(i+(1<<j)-1,n);\n\t\t\ttot=0;\n\t\t\tfor(int k=i;k<=r;k++)\n\t\t\tf[++tot]=k;\n\t\t\tsort(f+1,f+tot+1,cmp);\n\t\t\twhile(l<=r)\n\t\t\t{\n\t\t\t\tmid=(l+r)/2;\n\t\t\t\tif(calc())\n\t\t\t\t{\n\t\t\t\t\ti=mid;\n\t\t\t\t\tl=mid+1;\n\t\t\t\t}\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t\tcout<<ans<<endl;\n}\nint main()\n{\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\twork();\n\t}\n\treturn 0;\n}\n```\n","categories":["OI时期解题报告"]},{"title":"【解题报告】 POJ2299 超快速排序","url":"/2019/08/08/【解题报告】-POJ2299-超快速排序/","content":"\n# 【解题报告】POJ2299 超快速排序\n\n## 题目：[超快速排序](https://www.acwing.com/problem/content/109/)（已翻译）\n\n### 解题思路：\n\n归并排序求逆序对\n\n归并排序使我们众所周知的，我们只要在归并排序中计算每一个子序列中的逆序对数，我们就可以计算出总的逆序对数了，也就是\n$$\ncnt+=mid-i+1\n$$\n然后就完成了这道题\n\nAC代码\n\n```c++\n#include <iostream>\n#include <cstring>\nusing namespace std;\nint n;\nlong long cnt;\nconst int maxn=500005;\nlong long a[maxn];\nlong long b[maxn];\nvoid merge_sort(int l,int r)\n{\n    if(r>l)\n    {\n        int mid=(l+r)/2;\n        int i=l; \n        int p=l,q=mid+1;\n        merge_sort(l,mid);\n        merge_sort(mid+1,r);\n        while(p<=mid||q<=r)\n        {\n            if(q>r||(p<=mid&&a[p]<=a[q]))\n            b[i++] = a[p++];\n            else\n            {\n                b[i++]=a[q++];\n                cnt+=mid-p+1;\n            }\n        }\n        for(i=l;i<=r;i++)\n        a[i]=b[i];\n    }\n}\nint main()\n{\n\twhile(cin>>n&&n)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\t\tcnt=0;\n\t\tmerge_sort(1,n);\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}\n```\n\n顺便附上归并排序的代码\n\n```c++\n#include <iostream>\nusing namespace std;\nint n,cnt;\nconst int maxn=100005;\nlong long a[maxn];\nlong long b[maxn];\nvoid merge_sort(int l,int r)\n{\n    if(r>l)\n    {\n        int mid=(l+r)/2;\n        int i=l; \n        int p=l,q=mid+1;\n        merge_sort(l,mid);\n        merge_sort(mid+1,r);\n        while(p<=mid||q<=r)\n        {\n            if(q>r||(p<=mid&&a[p]<=a[q]))\n            b[i++] = a[p++];\n            else\n            {\n                b[i++]=a[q++];\n                cnt+=mid-p+1;\n            }\n        }\n        for(i=l;i<=r;i++)\n        a[i]=b[i];\n    }\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\tcin>>a[i];\n\tmerge_sort(1,n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcout<<a[i]<<\" \";\n\t}\n\tcout<<endl;\n\treturn 0;\n}\n\n```\n","categories":["OI时期解题报告"]},{"title":"【解题报告】 BZOJ3032 七夕祭","url":"/2019/08/08/【解题报告】-BZOJ3032-七夕祭/","content":"\n# 【解题报告】 BZOJ3032 七夕祭\n\n## 题目：[七夕祭](https://www.acwing.com/problem/content/107/)（翻译过的）\n\nps：话说今天是七夕节，我就正好做到七夕祭\n\n### 解题思路：\n\n看到这道题的题目，可以想到《均分纸牌》和我之前做的《货仓选址》两题，这样经过思考，演算和推理，我们可以得出，需要的最少步数是\n$$\n\\sum\\limits_{i=1}^M\\left|S[i]-s[k]\\right|\n$$\n其中S是A的前缀和，即\n$$\nS[i]=\\sum\\limits_{j=1}^iA[j]\n$$\n所以经过简单地编码，答案就出来了\n\nAC代码\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int maxn=100005;\nlong long a[maxn],b[maxn];\nlong long f[maxn];\nlong long n,m,t;\nlong long x,y;\nlong long calc(long long a[],long long n)\n{\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i]-=(a[0]/n);\n\t\tf[i]=f[i-1]+a[i];\n\t}\n\tsort(f+1,f+n+1);\n\tlong long mid=(n+1)>>1,ans=0;\n\tfor(int i=1;i<=n;i++)\n\tans+=abs(f[mid]-f[i]);\n\treturn ans;\n}\nint main()\n{\n\tcin>>n>>m>>t;\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tcin>>x>>y;\n\t\ta[x]++;\n\t\tb[y]++;\n\t}\n\tfor(int i=1;i<=n;i++)\n\ta[0]+=a[i];\n\tfor(int i=1;i<=m;i++)\n\tb[0]+=b[i];\n\tlong long c=a[0]%n,d=b[0]%m;\n\tif(!c&&!d)\n\tcout<<\"both \"<<calc(a,n)+calc(b,m);\n\telse if(!c)\n\tcout<<\"row \"<<calc(a,n);\n\telse if(!d)\n\tcout<<\"column \"<<calc(b,m);\n\telse\n\tcout<<\"impossible\";\n\tcout<<endl;\n\treturn 0;\n}\n```\n","categories":["OI时期解题报告"]},{"title":"【解题报告】 CH0501 货仓选址","url":"/2019/08/07/【解题报告】-CH0501-货仓选址/","content":"\n# 【解题报告】 CH0501 货仓选址\n\n## 题目：[货仓选址](https://www.acwing.com/problem/content/106/)\n\n### 解题思路：\n\n中位数\n\n中位数是一种美好的数，在数学中经常使用，这道题建立一个数组，读入数据，然后排序一下，假设货仓建在x处，x左边有p个商家，x右边有q个商家，如果p<q,那么把货仓向右移一个位置，距离之和就变小，类似地，p>q，就把货仓向左移一个位置，所以建在中间的时候距离之和最小\n\nAC代码\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int maxn=100005;\nint a[maxn],n,ans,pos;\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    cin>>a[i];\n    sort(a+1,a+1+n);\n    int pos=a[n/2+1];\n    for(int i=1;i<=n;i++)\n    ans+=abs(a[i]-pos);\n    cout<<ans<<endl;\n    return 0;\n}\n```\n","categories":["OI时期解题报告"]},{"title":"【解题报告】 CF67C Cinema","url":"/2019/08/06/【解题报告】-CF67C-Cinema/","content":"\n# 【解题报告】 CF67C Cinema\n\n## 题目：https://www.acwing.com/problem/content/105/\n\n### 解题思路：\n\n排序+离散化\n\nm部电影和n个人涉及2×m+n种语言。建立一个数组排序再离散化一下，用1到2×m+1之间的数来算。然后就暴力统计一下，就可以得出答案\n\nAC代码\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <set>\nusing namespace std;\nconst int maxn=5*10e5;\nint n,m;\nint a[maxn];\nint p[maxn];\nint w[maxn];\nint s[maxn];\nint q[maxn];\nint k[maxn];\nint ans1,ans2;\nint ans=1;\nvoid disc(int x)//离散化\n{\n\tint c;\n\tsort(p+1,p+x+1);\n\tfor(int i=1;i<=x;i++)\n\t{\n\t\tif(i==1||p[i]!=p[i-1])\n\t\tq[++c]=p[i];\n\t}\n\tq[0]=c;\n}\nint query(int x)//离散化的二分查询\n{\n\tint l=1,r=q[0],mid;\n\twhile(l<r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\tif(q[mid]>=x)\n\t\tr=mid;\n\t\telse\n\t\tl=mid+1;\n\t}\n\treturn l;\n}\nint main()\n{\n\tint c=0;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t\tp[++c]=a[i];\n\t}\n\tcin>>m;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tcin>>w[i];\n\t\tp[++c]=w[i];\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tcin>>s[i];\n\t\tp[++c]=s[i];\n\t}\n\tdisc(c);\n\tfor(int i=1;i<=n;i++)\n\tk[query(a[i])]++;//暴力统计\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=k[query(w[i])];\n\t\tint y=k[query(s[i])];\n\t\tif(x>ans1||(x==ans1&&y>ans2))\n\t\t{\n\t\t\tans=i;\n\t\t\tans1=x;\n\t\t\tans2=y;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n```\n","categories":["OI时期解题报告"]},{"title":"【解题报告】luogu P2078朋友","url":"/2019/08/06/【解题报告】luoguP2078朋友/","content":"\n# 【解题报告】luogu P2078 朋友\n\n### 题目：[luogu P2078](https://www.luogu.org/problem/P2078)\n\n题目思路：\n\n并查集，C++ STL\n\n有了C++stl容器，我们就high了，map可以处理数组下标为负的情况，然后男女朋友的关系的话，就分别统计每个公司有多少人有关系，取一个最小值就好了\n\nAC代码\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <map> \nusing namespace std;\nmap<int,int>f;\nint n,m,p,q;\nint fm,fh;\nint max(int a,int b)\n{\n\treturn a<b? a:b;\n} \nint get(int x)\n{\n\treturn f[x]=(x==f[x]? x:get(f[x]));\n}\nvoid merge(int x,int y)\n{\n\tf[get(x)]=get(y);\n}\nint main()\n{\n\tint x,y;\n\tcin>>n>>m>>p>>q;\n\tfor(int i=(-1*m);i<=n;i++)\n\tf[i]=i;\n\tfor(int i=1;i<=p+q;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tmerge(x,y);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(get(f[i])==get(1))\n\t\tfm++;\n\t}\n\tfor(int i=(-1*m);i<=-1;i++)\n\t{\n\t\tif(get(f[i])==get(-1))\n\t\tfh++; \n\t}\n\tcout<<max(fm,fh)<<endl;\n\treturn 0;\n}\n```\n","categories":["OI时期解题报告"]},{"title":"【解题报告】[HNOI2003]激光炸弹","url":"/2019/08/05/【解题报告】-HNOI2003-激光炸弹/","content":"\n# 【解题报告】 [HNOI2003]激光炸弹\n\n## 题目：[luogu P2280](https://www.luogu.org/problem/P2280)\n\n在这样可爱的夜晚，调试题目恐怕是最爽的选择了\n\n附：https://www.luogu.org/record/list?user=136889\n\n在这么多次失败下我终于成功了\n\n解题思路：\n\n前缀和与拆分\n\n这是一道简单题，但是我却调试了那么多次没调出来，竟然是循环的问题\n\nrp--。。\n\n建立一个二维数组，储存某个区域的目标的数量，然后就使用一个二维前缀和，就可以弄出来了，注意因为时间的原因，在输入的时候也就直接输入了，我那么多次就是因为超时\n\nAC代码\n\n```c++\n#include <iostream>\nusing namespace std;\nconst int maxn=5005;\nint r,n;\nint s[maxn][maxn];\nint ans;\nint x,y,w;\nint max(int a,int b)\n{\n\treturn a>b? a:b;\n}\nint main()\n{\n\tcin>>n>>r;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>x>>y>>w; \n\t\ts[x+1][y+1]=w;\n\t}\n\tfor(int i=1;i<=5001;i++)\n\t{\n\t\tfor(int j=1;j<=5001;j++)\n\t\ts[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];\n\t}\n\tfor(int i=0;i<=5001-r;i++)\n\t{\n\t\tfor(int j=0;j<=5001-r;j++)\n\t\tans=max(ans,s[i][j]-s[i+r][j]-s[i][j+r]+s[i+r][j+r]); \n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n```\n","categories":["OI时期解题报告"]},{"title":"【解题报告】[NOI2002]银河英雄传说","url":"/2019/08/04/【解题报告】-NOI2002-银河英雄传说/","content":"\n# 【解题报告】[NOI2002]银河英雄传说\n\n## 题目：[luogu P1196](https://www.luogu.org/problem/P1196)\n\n------\n\n### 题意简述\n\n处理M个指令，都为两种如下形式的指令之一\n\n1.M i j 表示让第i好战舰所在列的全部战舰保持原有顺序，接在第j好战舰所在列的尾部。\n\n2.C i j，表示询问第i号战舰与第j号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。如果不在同一列中，输出-1；\n\n### 解题思路\n\n并查集\n\n第二个指令我们要知道i，j两号战舰差多少，维护一个数列d即可，d[x]代表x前面的战舰数量,要查询的时候，我们只要知道i，j两号前面各有多少战舰，然后i前面的减去j前面的绝对值减一就可以了。\n\n而第一个指令就是简单地处理一下size，记录集合大小，也很简单\n\n### AC代码\n\n```c++\n#include <iostream>\n#include <cstdio>\nusing namespace std;\nint f[30005];\nint d[30005];\nint size[30005];\nint t;\nint jdz(int x)\n{\n\treturn x>0? x:(-x);\n}\nvoid init()\n{\n\tfor(int i=1;i<=30000;i++)\n\t{\n\t\tf[i]=i;\n\t\tsize[i]=1;\n\t}\n}\nint get(int x)\n{\n\tif(x==f[x])\n\treturn x;\n\tint root=get(f[x]);\n\td[x]+=d[f[x]];\n\treturn f[x]=root;\n}\nvoid merge(int x,int y)\n{\n\tx=get(x),y=get(y);\n\tf[x]=y;d[x]=size[y];\n\tsize[y]+=size[x];\n}\nint main()\n{\n\tcin>>t;\n\tinit();\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tchar s[2];\n\t\tint x,y;\n\t\tscanf(\"%s\",s);\n\t\tcin>>x>>y;\n\t\tif(s[0]=='M')\n\t\tmerge(x,y);\n\t\tif(s[0]=='C')\n\t\t{\n\t\t\tif(get(x)==get(y))\n\t\t\tcout<<jdz(d[x]-d[y])-1<<endl;\n\t\t\telse\n\t\t\tcout<<\"-1\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n\n数据情况https://www.luogu.org/record/22153408\n","categories":["OI时期解题报告"]},{"title":"幂运算","url":"/2019/08/03/幂运算/","content":"\n# 幂运算\n\n众所周知，在NOIP系列竞赛中，会考到许多优化，而这些许多优化是由一个个简单的优化组件而来的，使整个程序的优化尽可能地达到最大，用最少的时间和空间来实现正确代码，而幂运算作为其中的一个基本我今天就来总结一下，如有不足，以后也会加勘误and Update。\n\n### 幂\n\n普遍数学上幂的意义是一个数做自乘的运算，如a的b次方意思是b个a相乘，使表示上更加简便\n\n### 普通幂\n\nC++中普通幂的代码很容易实现，这是实现代码(基本实现代码)\n\n```c++\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int a,b;\n    cin>>a>>b;\n    for(int i=2;i<=b;i++)\n    a*=a;\n    cout<<a<<endl;\n    return 0;\n}\n```\n\n### 快速幂\n\n在普通幂中发现算很大的数的时候回非常地慢，我们就要想怎么优化，怎么优化呢，我们引入一组基本公式\n$$\na^b=a^{\\frac{b}{2}}*a^{\\frac{b}{2}}(b为偶数)\n$$\n\n$$\na^b=a^{\\frac{b}{2}}*a^{\\frac{b}{2}}*a(b为奇数)\n$$\n\n我们发现这样可以利用递归解决子问题来快速地算出a的b次方，加速了运算\n\n代码如下\n\n```c++\n#include <iostream>\nusing namespace std;\nint a,b;\nint quick_pow(int a,int b)\n{\n    if(b==0)\n        return 1;\n    int t=quick_pow(a,b/2);\n    if(b%2==1)\n        return t*t*a;\n    else\n        return t*t;\n}\nint main()\n{\n    cin>>a>>b;\n    cout<<quick_pow(a,b)<<endl;\n    return 0;\n}\n```\n\n或者代码也可以这样\n\n```c++\n#include <iostream>\nusing namespace std;\nint power(int a,int b,int p)\n{\n\tint ans=1%p;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\tans=(long long)ans*a%p;\n\t\ta=(long long)a*a%p; \n        b>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint a,b,p;\n\tcin>>a>>b>>p;\n\tcout<<power(a,b,p)<<endl;\n\treturn 0;\t\n} \n```\n\n特殊情况下算2的n次幂可以直接\n$$\n1<<n\n$$\n\n### 矩阵快速幂\n\n矩阵快速幂是一个对于矩阵的快速幂\n\n你还不知道什么是矩阵吗？（快速查看：[矩阵](http://www.baidu.com/link?url=Oht4LWR2XZyvOyurx8bBtzOMG9sQ9mw_uIB3vpDv4q5TNoowNK5mTGgpMgMYKjM38ablVMB_zKMS9hKcOJRRC9r1ohtbdNJZAH8qIhf2iaK&wd=&eqid=92e7f3720048392c000000035d443e83)）\n\n矩阵快速幂是对于矩阵乘法的自己多次相乘的快速运算\n\n和普通快速幂差不多，只是把‘*’换成了一个mul函数\n\n代码如下\n\n```c++\nmat mul(mat x,mat y)\n{\n\tmat c;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\tc.m[i][j]=0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\tc.m[i][j]=(c.m[i][j]%mod+(x.m[i][k]*y.m[k][j])%mod)%mod;\n\t\t}\n\t}\n\treturn c;\n}\n```\n\n因为要返回一个数组，所以为了方便，我们新建了一个结构体，也就是mat\n\n```c++\nstruct mat\n{\n    long long m[1005][1005];//用来存矩阵\n};\n```\n\n这样我们在写一个类似于普通快速幂的函数就成功解决问题了\n\n类普通快速幂函数\n\n```c++\nmat pow(mat a,long long b)\n{\n\tmat ans=e;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\tans=mul(ans,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n```\n\n所以我们就做出来了，但是为了使整个矩阵能保持原样，这个说不清，自己去看单位矩阵，然后这就是一个巧妙的地方\n\n```c++\nfor(int i=1;i<=n;i++)\n\te.m[i][i]=1;\n```\n\n最后，矩阵快速幂的一道模板题发给大家\n\n------\n\n#  lgP3390【模板】矩阵快速幂\n\n提交 25.45k\n\n通过 8.58k\n\n时间限制 1.00s\n\n内存限制 125.00MB\n\n### 题目背景\n\n矩阵快速幂\n\n### 题目描述\n\n给定n*n的矩阵A，求A^k\n\n### 输入格式\n\n第一行，n,k\n\n第2至n+1行，每行n个数，第i+1行第j个数表示矩阵第i行第j列的元素\n\n### 输出格式\n\n输出A^k\n\n共n行，每行n个数，第i行第j个数表示矩阵第i行第j列的元素，每个元素模10^9+7\n\n### 输入输出样例\n\n**输入 #1** \n\n```\n2 1\n1 1\n1 1\n```\n\n**输出 #1** \n\n```\n1 1\n1 1\n```\n\n### 说明/提示\n\nn<=100, k<=10^12, |矩阵元素|<=1000 算法：矩阵快速幂\n\n------\n\nAC代码\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int maxn=1005;\nconst int mod=1000000007; \nstruct mat\n{\n\tlong long m[maxn][maxn];\n};\nmat a,e;\nlong long n,p;\nmat mul(mat x,mat y)\n{\n\tmat c;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\tc.m[i][j]=0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\tc.m[i][j]=(c.m[i][j]%mod+(x.m[i][k]*y.m[k][j])%mod)%mod;\n\t\t}\n\t}\n\treturn c;\n}\nmat pow(mat a,long long b)\n{\n\tmat ans=e;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\tans=mul(ans,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tcin>>n>>p;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\tcin>>a.m[i][j];\n\t}\n\tfor(int i=1;i<=n;i++)\n\te.m[i][i]=1;a\n\tmat s=pow(a,p);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\tcout<<s.m[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n```\n\nPS:在自己电脑上可能输出不了，但是在洛谷IDE上能正常运行啊\n\n这就奇怪了，请问一下各位为什么\n\n下集预告：单源最短路径的优化或矩阵的简单介绍\n","categories":["学习笔记"]},{"title":"高级（线性）素数筛","url":"/2019/08/02/高级（线性）素数筛/","content":"\n# 高级（线性）素数筛\n\n在不久前，我已经介绍了简单素数筛，所以我们这次来介绍一下高级素数筛，实际上就是线性筛素数，很快地能把素数筛出来，但是我们平常竞赛的时候常用的还是那个简单素数筛，所以我这篇文章就来普及一下加自我练习一下啦！\n\n题目思路：\n\n之前的简单素数筛中的合数会被多个数重复标记，因此造成了冗余，所以我们要想办法在这个方面优化，我们就想到了合数只要被它的最小质因子标记了一遍之后就不再标记了，这就减少了很大一部分的冗余，速度也就变快了。\n\n大概过程如下：\n\n1.从2~n之间枚举\n\n2.如果v[i]=i,那么i就是质数\n\n3.枚举小于等于v[i]的每个质数，让v[i*p]=p，在i的基础上在乘一个质因子p，得到一个新的数。\n\n4.因为p<=v[i]，所以p就是 合数i*p的最小质因子。\n\n|    i    | 2    | 3    | 4    | 5        | 6    | 7           | 8    | 9      | 10   |\n| :-----: | ---- | ---- | ---- | -------- | ---- | ----------- | ---- | ------ | ---- |\n| p<=v[i] | 2    | 2,3  | 2    | 2,3,5    | 2    | 2,3,5,7     | 2    | 2,3    | 2    |\n|   i*p   | 4    | 6,9  | 8    | 10,15,25 | 12   | 14,21,35,49 | 16   | 18,.27 | 20   |\n\nps:以上表格来自《算法竞赛进阶指南》\n\n因此我们就通过这种方法制作出了线性筛素数的程序\n\n代码如下，时间复杂度\n$$\nO(n)\n$$\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int maxn=10000005;\nint v[maxn],p[maxn];\nvoid primes(int n)\n{\n\tint m=0;\n\tmemset(v,0,sizeof(v));\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(v[i]==0)\n\t\t{\n\t\t\tv[i]=i;\n\t\t\tp[++m]=i;\n\t\t}\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tif(p[j]>v[i]||p[j]>(n/i))\n\t\t\tbreak;\n\t\t\tv[i*p[j]]=p[j];\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tcout<<p[i]<<endl;\n\t}\n} \nint main()\n{\n\tint n;\n\tcin>>n;\n\tprimes(n);\n\treturn 0;\n}\n```\n\n------\n\n接下来我们来一道例题练练手\n\n题目：[luogu P3383 【模板】线性筛素数](https://www.luogu.org/problem/P3383)\n\n我帮大家复制了一下题面\n\n### 题目描述\n\n如题，给定一个范围N，你需要处理M个某数字是否为质数的询问（每个数字均在范围1-N内）\n\n### 输入格式\n\n第一行包含两个正整数N、M，分别表示查询的范围和查询的个数。\n\n接下来M行每行包含一个不小于1且不大于N的整数，即询问该数是否为质数。\n\n### 输出格式\n\n输出包含M行，每行为Yes或No，即依次为每一个询问的结果。\n\n### 输入输出样例\n\n**输入 #1** \n\n```\n100 5\n2\n3\n4\n91\n97\n```\n\n**输出 #1** \n\n```\nYes\nYes\nNo\nNo\nYes\n```\n\n### 说明/提示\n\n时空限制：500ms 128M\n\n数据规模：\n\n对于30%的数据：N<=10000，M<=10000\n\n对于100%的数据：N<=10000000，M<=100000\n\n样例说明：\n\nN=100，说明接下来的询问数均不大于100且不小于1。\n\n所以2、3、97为质数，4、91非质数。\n\n故依次输出Yes、Yes、No、No、Yes。\n\n------\n\n题目思路：这道题很简单，就是把刚才的代码稍加改动，判断一下只要v[i]==i，就是素数，否则就不是素数\n\n代码如下\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int maxn=10000005;\nint v[maxn],p[maxn];//v代表v是不是质数，是的话为1，p为质数\nvoid primes(int n)\n{\n\tint m=0;\n\tmemset(v,0,sizeof(v));\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(v[i]==0)\n\t\t{\n\t\t\tv[i]=i;\n\t\t\tp[++m]=i;\n\t\t}\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tif(p[j]>v[i]||p[j]>(n/i))\n\t\t\tbreak;\n\t\t\tv[i*p[j]]=p[j];\n\t\t}\n\t}\n} \nint main()\n{\n\tint n,q,r;\n\tcin>>n>>q;\n\tprimes(n);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tcin>>r;\n\t\tif(r==0||r==1)\n\t\t{\n\t\t\tcout<<\"No\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(v[r]==r)\n\t\tcout<<\"Yes\"<<endl;\n\t\telse\n\t\tcout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}\n```\n\n下集预告:单源最短路径优化版或其他\n","categories":["学习笔记"]},{"title":"Dijkstra（迪杰斯特拉）算法","url":"/2019/07/31/Dijkstra（迪杰斯特拉）算法/","content":"\n# Dijkstra（迪杰斯特拉）算法\n\n晚上是个好时间去刷题，我今天就看了Dijkstra算法，名字倒挺不好读的，所以我进行了深入思考，终于把一个看起来很难的算法，实际上不太简单的算法弄懂了，先来介绍一下Dijkstra\n\n> 迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。\n>\n> ——来自《百度百科》\n\n这个荷兰科学家还是比较厉害的。\n\n我们就开始看Dijkstra了。\n\nDijkstra是一个基于贪心的最短路算法，不能处理权值为负的情况，是单源的最短路算法的一种\n\n这个算法的主要过程如下：\n\n> 1.建一个数组d[n]，表示从第n个节点到第1个节点的最短距离，然后初始化d[1]=1，其他的为正无穷。\n>\n> 2.遍历找到一个没有被覆盖的d[x]的最小的节点x，然后标记x\n>\n> 3.尝试x的每个出边(x,y,z)，如果d[y]>d[x]+z,就赋值d[y]=d[x]+z;（z为x到y的距离）；\n>\n> 4.最后重复以上过程，直到所有的点都被标记，就完事儿了\n\n我们就完成了单源最短路径，代码如下：\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint a[3010][3010],d[3010],n,m;\nbool v[3010];\nint min(int a,int b)//最小值函数\n{\n\treturn a<b? a:b;\n}\nvoid dijkstra()//单源最短路径\n{\n\tmemset(d,0x3f,sizeof(d));//初始化数组d的元素为正无穷\n\tmemset(v,0,sizeof(v));//初始化数组v为0\n\td[1]=0;//第一个节点到它自己的距离为0\n\tfor(int i=1;i<n;i++)//开始循环\n\t{\n\t\tint x=0;\n\t\tfor(int j=1;j<=n;j++)//内层循环\n\t\t{\n\t\t\tif(!v[j]&&(x==0||d[j]<d[x]))\n\t\t\tx=j;\n\t\t}\n\t\tv[x]=1;\n\t\tfor(int y=1;y<=n;y++)//类似一个动态规划的过程但不是\n\t\td[y]=min(d[y],d[x]+a[x][y]); \n\t}\n}\nint main()\n{\n\tcin>>n>>m;//输入一个n*m的邻接矩阵\n\tmemset(a,0x3f,sizeof(a));//初始化数组a为正无穷\n\tfor(int i=1;i<=n;i++)\n\ta[i][i]=0;//一个点到它自己的距离为0\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y,z;\n\t\tcin>>x>>y>>z;//x到y的距离是z\n\t\ta[x][y]=min(a[x][y],z);//x到y的距离要保证是小的\n\t}\n\tdijkstra();//开始Dijkstra\n\tfor(int i=1;i<=n;i++)//输出结果\n\tcout<<d[i]<<endl;\n\treturn 0;//完美撒花！\n}\n```\n\n时间复杂度\n$$\nO(n^2)\n$$\n下期预告：\n\n高级素数筛或者单源最短路径优化版\n","categories":["学习笔记"]},{"title":"简单素数筛","url":"/2019/07/29/简单素数筛/","content":"\n# 简单素数筛\n\n今天，我看了一些数学知识，而数论是比较主要的，而素数筛是其中重要的一个，现在来介绍一下简单素数筛\n\n首先来，普及一下素数的概念\n\n> 若一个正整数无法被除了1和它本身之外的任何自然数整除，则称该数为素数，也称质数（或素数），否则称该正整数为合数。\n\n通过介绍质数（下文统称质数）的概念，我们知道了一种判断质数的方法\n\n**通过枚举**：这种方法的速度太慢了，因此我们需要更快的方法\n\nps：即使从1枚举到根号n也是很慢的\n\n所以我们要引进一种好方法\n\n就是大于二的所有数的倍数都是合数，那就好办了，我们可以从2开始（先初始化一个v[]数组的所有元素为零）2的倍数都是合数，标记v[i*j]为一,3的倍数都是合数，标记为1……\n\n以此类推，我们就可以得出答案了\n\n下面有一道例题\n\n------\n\n### 题目描述\n\n给定一个范围N，你需要处理M个某数字是否为质数的询问（每个数字均在范围1-N内）\n\n### 输入格式\n\n第一行包含两个正整数N、M，分别表示查询的范围和查询的个数。\n\n接下来M行每行包含一个不小于1且不大于N的整数，即询问该数是否为质数。\n\n### 输出格式\n\n输出包含M行，每行为Yes或No，即依次为每一个询问的结果。\n\n### 输入输出样例\n\n**输入 #1** \n\n```\n100 5\n2\n3\n4\n91\n97\n```\n\n**输出 #1** \n\n```\nYes\nYes\nNo\nNo\nYes\n```\n\n### 说明/提示\n\n时空限制：500ms 128M\n\n数据规模：\n\n对于100%的数据：N<=10000，M<=10000\n\n样例说明：\n\nN=100，说明接下来的询问数均不大于100且不小于1。\n\n所以2、3、97为质数，4、91非质数。\n\n故依次输出Yes、Yes、No、No、Yes。\n\n------\n\n这道题就是一道标准的筛素数的题，因为它要访问多个数啊，不做素数筛不可以啊，所以经过努力，我写出了代码\n\n```c++\n#include <iostream>\n#include <cstring>\nusing namespace std;\nint v[10000005];//记录用\nint n,m;\nint p;\nvoid primes(int n)//简单素数筛函数\n{\n\tmemset(v,0,sizeof(v));\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(v[i])\n\t\tcontinue;\n\t\tfor(int j=i;j<=n/i;j++)\n\t\tv[i*j]=1; \n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tprimes(n);//调用函数\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tcin>>p;\n\t\tif(v[p])\n\t\tcout<<\"No\"<<endl;\n\t\telse \n\t\tcout<<\"Yes\"<<endl;\n\t}\n\treturn 0;\n}\n```\n\n这就是简单素数筛，你get到了吗？\n\n下集预告：高级素数筛（或其他的）\n","categories":["学习笔记"]},{"title":"【解题报告】 POJ1958 奇怪的汉诺塔","url":"/2019/07/28/【解题报告】-POJ1958-奇怪的汉诺塔/","content":"\n# 【解题报告】 POJ1958 奇怪的汉诺塔\n\n> 在这样热浪滚滚的暑假，外面晴空高照，在家里刷刷题不妨是最好的选择\n>\n> ——来自wweiyi语录\n\n题目链接（翻译过的）：\n\nhttps://www.acwing.com/problem/content/98/\n\n题意简述：输出四个塔的汉诺塔分别从1个盘子到12个盘子的最少步数\n\n![河内塔.jpg](https://www.acwing.com/media/article/image/2019/01/10/19_acbb764014-河内塔.jpg)\n\n\n\n我们看了题之后，可以知道这道题跟三个塔的汉诺塔一样，用递归，但是我们设先移走i个盘子到第二个塔或第三个塔，然后就转化成三个塔的问题了。\n\n但是问题在于不知道i等于多少，而且直接输出12个值要用递归也会有些慢，所以我们做一下优化，记忆化一下，我们就可以很快的输出了\n\n设三个塔n个盘子的步数为d[n],设四个塔n个盘子的步数为f[n]\n\n动态转移方程如下\n$$\nf_n=min(f_n,2f_i+d_{n-i})\n$$\n其中\n$$\n1\\leq n,i \\leq 12\n$$\n所以我们就解决了这道题目\n\n代码如下\n\n```c++\n#include <iostream>\n#include <cstring>\nusing namespace std;\nint d[15];\nint f[15];\nint min(int a,int b)//最小值函数\n{\n\treturn a<b? a:b;\n}\nint main()\n{\n\td[1]=1;//汉诺三塔边界\n\tfor(int i=2;i<=12;i++)//计算汉诺三塔的数值\n\td[i]=2*d[i-1]+1;\n\tmemset(f,0x3f,sizeof f);//因为要求最小值，所以初始一个极大值\n\tf[1]=1;//汉诺四塔边界\n\tfor(int i=2;i<=12;i++)//动态规划\n\t{\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tf[i]=min(f[i],2*f[j]+d[i-j]);//状态转移方程\n\t\t}\n\t}\n\tfor(int i=1;i<=12;i++)\n\tcout<<f[i]<<endl;//输出\n\treturn 0;\n}\n```\n","categories":["OI时期解题报告"]},{"title":"学习笔记 简单的amodb A%B Problem","url":"/2019/07/28/学习笔记-简单的amodb-A-B-Problem/","content":"\n# 【基础题目】A%B Problem\n\n#### 题目描述\n\n> C--语言是一种C的简化版，它仅有的三种运算符为++，--和==（没有=，+，-，*，/，%，<,>等任何其他运算符），也没有循环及goto语句，除此之外与C相同。使用C--编写一个函数int\n> mod(int a,int b)，计算a除以b的余数。\n>\n> ——来自wweiyi暑假集训\n\n**题意简述**：只用++,--,==运算符和C++的其他功能来完成a%b的功能\n\n提示：允许调用其他函数\n\n这是一道神奇的题目，我想了大半天才想出来，甚至引来了老师的批评，接下来我说一说我的思路\n\n这道题我们需要只用++,--,==和C++的其他功能来实现模运算，这个看起开似乎无法实现，因为不能够使用循环，因此，这道题的阴影加深了。\n\n#### 递归！循环的后裔！\n\n这里我们不能用循环，也就是我们需要使用类似循环的一个过程，递归来解决问题，递归是一种很常用的解决问题的方法，将一个大问题转换成一个子问题也许模运算就可以这样解决了。\n\n#### ++，--，==三运算符！三符成虎！\n\n我们要解决模运算首先要解决减法运算的问题，因为a%b，就是a一直减b，减到a小于b为止，因此，我们可以先解决减法运算。\n\n代码如下\n\n```c++\nint jian(int a,int b)\n{\n    if(b==0)\n        return a;\n    return jian(--a,--b);\n}\n```\n\n这样就解决了减法运算；\n\n但是顺便说一句，加法和乘法运算实际上也很简单，让我来把代码贴出来！\n\n```c++\nint add(int a,int b)\n{\n    if(b==0)\n        return a;\n    return add(++a,--b);\n}\nint cheng(int a,int b)\n{\n    if(b==0)\n        return a;\n    return add(a,cheng(a,--b));\n}\n```\n\n我们可以轻松地解决减法，乘法和加法，但是模运算我们还是不知道，怎么办呢？\n\n#### 判断！事情的转机？\n\n我们再次理清一下思路，我们需要a一直减b，一直减到a小于b为止，也就是mod(a,b)=mod(a-b,b)，这就是神奇的递归式，就可以解决一部分问题，另一部分问题就是判断a小于b，我们可以a，b同时递减，看谁先到0，但由于这个问题的特殊性，当a=b时，需要特殊判断一下，因为一个数mod它的因数等于0，所以我们的思路就出来了，代码也就写出来了。\n\n代码如下\n\n```c++\n#include <iostream>\nusing namespace std;\nint pd(int a,int b)\n{\n\tif(a==b)\n\treturn 0;\n\tif(a==0)\n\treturn 1;\n\tif(b==0)\n\treturn 0;\n\treturn pd(--a,--b);\n}\nint jian(int a,int b)\n{\n\tif(b==0)\n\treturn a;\n\treturn jian(--a,--b);\n}\nint mod(int a,int b)\n{\n\tif(pd(a,b)==1)\n\treturn a;\n\treturn mod(jian(a,b),b);\n}\nint main()\n{\n\tint a,b;\n\tcin>>a>>b;\n\tcout<<mod(a,b)<<endl;\n\treturn 0;\n}\n//wweiyi费时3小时智造\n```\n","categories":["学习笔记"]},{"title":"最大公约数的故事","url":"/2019/07/26/最大公约数的故事/","content":"\n# 最大公约数的故事\n\n> **最大公因数**，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。a，b的最大公约数记为（a，b），同样的，a，b，c的最大公约数记为（a，b，c），多个整数的最大公约数也有同样的记号。——来自《百度百科》\n\n[^]: 两个数的最大公约数a，b一般用gcd（a，b）来表示，因此，我后文也会用gcd（ ， ）来表示两个数的最大公约数\n\n最大公约数在计算机中也很常用，而对于这种数了解最深的非欧几里得莫属了！\n\n### 欧几里得\n\n> **欧几里得**（英文：Euclid；希腊文：Ευκλειδης，约公元前330年—公元前275年），古希腊人，数学家，被称为“几何之父”。他最著名的著作《几何原本》是欧洲数学的基础，提出五大公设，欧几里得几何，被广泛的认为是历史上最成功的教科书。欧几里得也写了一些关于透视、圆锥曲线、球面几何学及**数论**的作品。——来自《百度百科》\n\n特别是数论方面有很深的造诣，因此我们今天计算机中关于数论的东西有很可观的一部分来自欧几里得，所以我们在这里看一下最大公约数。\n\n### 如何算最大公约数？\n\n#### 质因数分解法\n\n这是一个好问题，最简单的方法是用质因数分解法\n\n例如：gcd（24,21）\n\n质因数分解得：\n\n24=2 * 2 * 2 * 3\n\n21=3 * 7\n\n它们公共的因数有3，因此，它们的最大公约数是3；\n\n这个办法我们需要用到质因数分解，质因数分解代码如下：\n\n```c++\n#include <iostream>\nusing namespace std;\nbool first=true;\nvoid zyz(int n,int p)\n{\n    if(n>1)\n    {\n        if(n%p==0)\n        {\n            if(first)\n            {\n                cout<<p;\n                first=false;\n            }\n            else cout<<\" \"<<p;\n            zyz(n/p,p);\n        }\n        else zyz(n/p+1);\n    }\n}\nint main()\n{\n    int n;\n    cin>>n;\n    zyz(n,2);\n    cout<<endl;\n    return 0;\n}\n//选自信息学奥赛课课通（C++）\n```\n\n#### 更相减损法\n\n但是这样寻找最大公约数太慢了，怎么办呢？\n\n中国古代《九章算术》中有一种方法，称为“更相减损法”\n\n方法是\n$$\ngcd(a,b)=gcd(b,a-b)\n$$\n，这样一直递归下去，当b等于0是，a‘就是a，b的最大公约数。\n\n但这种方法太慢了，有一种更好的方法，我们在下面介绍。\n\n#### 辗转相除法\n\n辗转相除法是欧几里得算法，是求最大公约数最常见的方法，我们来看一看。\n\n我们仔细观察更相减损法，可以发现，gcd（a,b）=gcd(b,a-b)中右边的那一项是一直减b的因此，我们可以联想到计算机中的mod运算(%)，这样效率就大大地加高了。\n\n递推式\n$$\ngcd(a,b)=gcd(b,a模b)\n$$\n所以我们就可以用递归快速求出最大公约数\n\n代码如下\n\n```c++\nint gcd(int a,int b)\n{\n    return b? gcd(b,a%b):a;\n}\n```\n\n这样就完成了求最大公约数\n\n### 惊现！求逆元！\n\n> 如果：a×b≡1 (mod n)\n>\n> 那么：\n>\n>    a×m≡a×k (mod n)\n> => b×a×m≡b×a×k (mod n)\n> => m≡k (mod n)\n>\n> 前提是b存在！\n>\n> b称为a模n的逆元（a也是b模n的逆元）\n>\n> x模n的逆元也记作\n> $$\n> x^{-1}(mod  (n))\n> $$\n> ——来自wweiyi的暑假集训\n\n这样就可以放心地使用同余中的除法运算了，是不是很帅？？？\n\n因为一个数%n的余数只有可能是0~n-1，又因为0不可能是一个数在模n意义下的逆元，所以我们可以枚举求逆元（From 1 to n-1） 所以，我们可以这样求\n\n代码如下：\n\n```c++\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int a,b,n;\n    cin>>a>>n;//表示求a在模n意义下的逆元\n    for(int i=1;i<=n-1;i++)\n    {\n        if((a*i)%n==1)\n        {\n            b=i;break;\n        }\n    }\n    cout<<b<<endl;\n    return 0;\n}\n```\n\nb就是a在模n意义下的乘法逆元，但是我们看下面一个例子：\n\n> 例如：11模7的逆元\n>\n> \t\t\t(11,7) \t  (a,b)\n> \t\t\t\n> \t\t\t(7,4) \t\t(b,a-b)\n> \t\t\t\n> \t\t\t(4,3)         (a-b,2b-a)\n> \t\t\t\n> \t\t\t(3,1)         (2b-a,**2a-3b**)\n> \t\t\t\n> \t\t\t即：2×11-3×7=1\n> \t\t\t\n> \t\t\t2×11≡1 (mod 7)\n> \t\t\t\n> \t\t\t∴11模7的逆元是2\n>\n> ——来自wweiyi暑假集训\n\n有没有发现，这个就是gcd(11,7)的过程，只不过右边用字母代替了它的运算，但实际上是一样的，而到最后一步时，后边加粗的a的系数就是11模7的逆元！是不是很神奇！\n\n所以我们就有了又快又简便的方法来求逆元\n\n代码如下\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint b,x,y,mod,gcd; \ninline int exgcd(int a,int b,int &x,int &y)\n{\n    if(b==0)\n    {\n        x=1,y=0;\n        return a;\n    }\n    int ret=exgcd(b,a%b,x,y);\n    int t=x;x=y,y=t-(a/b)*y;\n    return ret;\n}\nint main()\n{\n    cin>>b>>mod;\n    gcd=exgcd(b,mod,x,y);\n    if(gcd!=1)printf(\"not exist\\n\");\n    else printf(\"%d\\n\",(x%mod+mod)%mod);\n    return 0;\n}\n/*来自 WJEMail大佬\n网址:\nhttps://www.cnblogs.com/NSDemail0820/p/9910344.html#_label2\n*/\n```\n\n这样我们求出逆元了\n\n### 神奇！求形如ax+by=c的不定方程整数解和形如ax≡1（mod n）的同余方程\n\n> gcd (25,7)\n>\n> (25,7)     (a,b)\n>\n> (7,4)       (b,a-3b)\n>\n> (4,3)       (a-3b,4b-a)\n>\n> (3,1)       (4b-a,2a-7b)\n>\n> (1,0)       (2a-7b,25b-7a)\n>\n> ——来自wweiyi的暑假培训\n\n#### ax+by=c\n\n也就是使用拓展欧几里得：\n\n> **扩展欧几里德算法**是用来在已知a, b求解一组x，y，使它们满足贝祖等式： \n> $$\n> ax+by\n> = gcd(a, b) =d\n> $$\n> （解一定存在，根据数论中的相关定理）。扩展欧几里德常用在求解模线性方程及方程组中。\n>\n> ——来自《百度百科》\n\n有解的条件：gcd(a,b)|c\n\n因此我们就可以解这样一个方程了!\n\n代码如下\n\n```C++\n#include <iostream>\nusing namespace std;\nint exgcd_x(int c,int d,int x1,int y1,int x2,int y2)\n{\n\treturn d?exgcd_x(d,c%d,x2,y2,x1-(c/d)*x2,y1-(c/d)*y2):x1;\n}\nint exgcd_y(int c,int d,int x1,int y1,int x2,int y2)\n{\n\treturn d?exgcd_y(d,c%d,x2,y2,x1-(c/d)*x2,y1-(c/d)*y2):y1;\n}\nint gcd(int c,int d)\n{\n\treturn d?gcd(d,c%d):c;\n}\nint main()\n{\n\tint a,b,n;\n\tint x1=1,y1=0,x2=0,y2=1;\n\tcin>>a>>b>>n;\n\tif(n%gcd(a,b)!=0)\n\t{\n\t\tcout<<\"No solution\"<<endl;\n\t\treturn 0;\n\t}\n\tint x=exgcd_x(a,b,x1,y1,x2,y2);\n\tint y=exgcd_y(a,b,x1,y1,x2,y2);\n\tint g=n/gcd(a,b);\n\tcout<<x*g<<\"a\"<<y*g<<\"b=\"<<n<<endl;\n\treturn 0;\n}\n```\n\n#### ax≡1(mod n)\n\n实际上就是求逆元！\n\n这里就不再多说了!\n\n**总结：这个欧几里得算法和拓展欧几里得算法是很有用的算法，我们会很常用，因此我们要熟悉掌握这个算法，在OI竞赛中帮助我们，今天就到这里了**\n","categories":["学习笔记"]},{"title":"汉诺塔问题","url":"/2019/07/26/汉诺塔问题/","content":"# 汉诺塔问题（Hanoi Tower Problem）\n\n汉诺塔问题家喻户晓，它源于一个印度的神话，内容如下：\n\n在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。\n\n这个问题看起来十分可怕，实际上很简单。接下来就解决一个问题来体会这个小小问题中的大大的递归思想！\n\n>有三根柱子，第一根柱子上有n个从下向上越来越小的圆盘。\n\n>目标：使第一根柱子上的n个圆盘按原样摆放在另一个柱子上。\n\n>注：一次移动一个圆盘，不可以出现大的盘子在小的盘子上面的情况。\n\n解：\n首先我们先玩一下这个游戏。\n\n接着我们找出一个规律，要彻底地把这个塔移开，我们必须要移开上方的n-1个盘子，使最下面的盘子可以移动到另一个柱子上，然后在把上方的n-1个盘子移动到最下\n面的盘子（也就是最大的盘子）上就可以解决了。而n-1个盘子的移动方法也一样，因为最下面的大盘子对上面的n-1个盘子的移动毫无影响。\n\n因此，我们可以得出一个递推式：\n$$\nF_n=2F_{n-1}+1\n$$\n$F_n$代表第一个柱子上有n个盘子的情况，所以这个问题得到了解决\n\n代码如下：时间复杂度$O(2^n )$\n```c++\n#include <iostream>\nusing namespace std;\nint main()\n{\n\tint n;\n\tint f[20];\n\tcin>>n;\n\tf[1]=1;\n\tfor(int i=2;i<=n;i++)\n\tf[i]=2*f[i-1]+1;\n\tcout<<f[n]<<endl;\n\treturn 0; \n}\n```\n\n这个问题就简单地这么解决了。（瞎说，还有更简单的方法）\n\n让我们来看一看输出结果：从n=1开始:1 3 7 15 31 63 127 255 511 1023 2047 4095 8191……\n\n我们发现一个规律，所有的$F_n$满足：\n\n$$\nF_n=2^n-1\n$$\n\n这才是最简单的方法！\n\n有些人会说，这个方法是瞎猜的，只是凭运气而已，没事儿，我可以证明一下。\n\n证：\n数学归纳法。\n当 $n=1$ 时，$F(n)=1,2n-1=1$ ;命题显然成立\n假设 $n=k$ 时命题成立，即$F(k)=2k-1$；\n当 $n=k+1$ 时，$F(k+1)=F(k)*2+1$ ;\n因为$F(k)=2^k-1$\n所以 \n$F(k+1)$\n $=2F(k)+1$\n $=(2^k-1)*2+1$\n $=2^{k+1}-1$\n证毕。\n所以这才是这种汉诺塔问题的最优解！\n\n最终代码如下：时间复杂度O(⁡$log_2n$ )\n```c++\n#include <iostream>\nusing namespace std;\nint qp(int a,int b)\n{\n\tif(b==0)\n\treturn 1;\n\tint t=qp(a,b/2);\n\tif(b%2==0)\n\treturn t*t;\n\telse\n\treturn t*t*a;\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tcout<<qp(2,n)-1<<endl;\n\treturn 0;\n}\n```\n","categories":["学习笔记"]}]