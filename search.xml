<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>wweiyi-first-blog</title>
    <url>/2025/07/08/wweiyi-first-blog/</url>
    <content><![CDATA[今天我重新创建了我的hexo驱动的blog，希望以后这个blog能够时常更新吧
]]></content>
  </entry>
  <entry>
    <title>Dijkstra（迪杰斯特拉）算法</title>
    <url>/2019/07/31/Dijkstra%EF%BC%88%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%EF%BC%89%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[Dijkstra（迪杰斯特拉）算法
晚上是个好时间去刷题，我今天就看了Dijkstra算法，名字倒挺不好读的，所以我进行了深入思考，终于把一个看起来很难的算法，实际上不太简单的算法弄懂了，先来介绍一下Dijkstra

迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。
——来自《百度百科》

这个荷兰科学家还是比较厉害的。
我们就开始看Dijkstra了。
Dijkstra是一个基于贪心的最短路算法，不能处理权值为负的情况，是单源的最短路算法的一种
这个算法的主要过程如下：

1.建一个数组d[n]，表示从第n个节点到第1个节点的最短距离，然后初始化d[1]=1，其他的为正无穷。
2.遍历找到一个没有被覆盖的d[x]的最小的节点x，然后标记x
3.尝试x的每个出边(x,y,z)，如果d[y]&gt;d[x]+z,就赋值d[y]=d[x]+z;（z为x到y的距离）；
4.最后重复以上过程，直到所有的点都被标记，就完事儿了

我们就完成了单源最短路径，代码如下：
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int a[3010][3010],d[3010],n,m;bool v[3010];int min(int a,int b)//最小值函数&#123;	return a&lt;b? a:b;&#125;void dijkstra()//单源最短路径&#123;	memset(d,0x3f,sizeof(d));//初始化数组d的元素为正无穷	memset(v,0,sizeof(v));//初始化数组v为0	d[1]=0;//第一个节点到它自己的距离为0	for(int i=1;i&lt;n;i++)//开始循环	&#123;		int x=0;		for(int j=1;j&lt;=n;j++)//内层循环		&#123;			if(!v[j]&amp;&amp;(x==0||d[j]&lt;d[x]))			x=j;		&#125;		v[x]=1;		for(int y=1;y&lt;=n;y++)//类似一个动态规划的过程但不是		d[y]=min(d[y],d[x]+a[x][y]); 	&#125;&#125;int main()&#123;	cin&gt;&gt;n&gt;&gt;m;//输入一个n*m的邻接矩阵	memset(a,0x3f,sizeof(a));//初始化数组a为正无穷	for(int i=1;i&lt;=n;i++)	a[i][i]=0;//一个点到它自己的距离为0	for(int i=1;i&lt;=m;i++)	&#123;		int x,y,z;		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;//x到y的距离是z		a[x][y]=min(a[x][y],z);//x到y的距离要保证是小的	&#125;	dijkstra();//开始Dijkstra	for(int i=1;i&lt;=n;i++)//输出结果	cout&lt;&lt;d[i]&lt;&lt;endl;	return 0;//完美撒花！&#125;
时间复杂度
O(n2)O(n^2)
O(n2)
下期预告：
高级素数筛或者单源最短路径优化版
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 BZOJ3032 七夕祭</title>
    <url>/2019/08/08/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-BZOJ3032-%E4%B8%83%E5%A4%95%E7%A5%AD/</url>
    <content><![CDATA[【解题报告】 BZOJ3032 七夕祭
题目：七夕祭（翻译过的）
ps：话说今天是七夕节，我就正好做到七夕祭
解题思路：
看到这道题的题目，可以想到《均分纸牌》和我之前做的《货仓选址》两题，这样经过思考，演算和推理，我们可以得出，需要的最少步数是
∑i=1M∣S[i]−s[k]∣\sum\limits_{i=1}^M\left|S[i]-s[k]\right|
i=1∑M​∣S[i]−s[k]∣
其中S是A的前缀和，即
S[i]=∑j=1iA[j]S[i]=\sum\limits_{j=1}^iA[j]
S[i]=j=1∑i​A[j]
所以经过简单地编码，答案就出来了
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn=100005;long long a[maxn],b[maxn];long long f[maxn];long long n,m,t;long long x,y;long long calc(long long a[],long long n)&#123;	for(int i=1;i&lt;=n;i++)	&#123;		a[i]-=(a[0]/n);		f[i]=f[i-1]+a[i];	&#125;	sort(f+1,f+n+1);	long long mid=(n+1)&gt;&gt;1,ans=0;	for(int i=1;i&lt;=n;i++)	ans+=abs(f[mid]-f[i]);	return ans;&#125;int main()&#123;	cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;	for(int i=1;i&lt;=t;i++)	&#123;		cin&gt;&gt;x&gt;&gt;y;		a[x]++;		b[y]++;	&#125;	for(int i=1;i&lt;=n;i++)	a[0]+=a[i];	for(int i=1;i&lt;=m;i++)	b[0]+=b[i];	long long c=a[0]%n,d=b[0]%m;	if(!c&amp;&amp;!d)	cout&lt;&lt;&quot;both &quot;&lt;&lt;calc(a,n)+calc(b,m);	else if(!c)	cout&lt;&lt;&quot;row &quot;&lt;&lt;calc(a,n);	else if(!d)	cout&lt;&lt;&quot;column &quot;&lt;&lt;calc(b,m);	else	cout&lt;&lt;&quot;impossible&quot;;	cout&lt;&lt;endl;	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 CF67C Cinema</title>
    <url>/2019/08/06/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-CF67C-Cinema/</url>
    <content><![CDATA[【解题报告】 CF67C Cinema
题目：https://www.acwing.com/problem/content/105/
解题思路：
排序+离散化
m部电影和n个人涉及2×m+n种语言。建立一个数组排序再离散化一下，用1到2×m+1之间的数来算。然后就暴力统计一下，就可以得出答案
AC代码
#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;set&gt;using namespace std;const int maxn=5*10e5;int n,m;int a[maxn];int p[maxn];int w[maxn];int s[maxn];int q[maxn];int k[maxn];int ans1,ans2;int ans=1;void disc(int x)//离散化&#123;	int c;	sort(p+1,p+x+1);	for(int i=1;i&lt;=x;i++)	&#123;		if(i==1||p[i]!=p[i-1])		q[++c]=p[i];	&#125;	q[0]=c;&#125;int query(int x)//离散化的二分查询&#123;	int l=1,r=q[0],mid;	while(l&lt;r)	&#123;		mid=(l+r)&gt;&gt;1;		if(q[mid]&gt;=x)		r=mid;		else		l=mid+1;	&#125;	return l;&#125;int main()&#123;	int c=0;	cin&gt;&gt;n;	for(int i=1;i&lt;=n;i++)	&#123;		cin&gt;&gt;a[i];		p[++c]=a[i];	&#125;	cin&gt;&gt;m;	for(int i=1;i&lt;=m;i++)	&#123;		cin&gt;&gt;w[i];		p[++c]=w[i];	&#125;	for(int i=1;i&lt;=m;i++)	&#123;		cin&gt;&gt;s[i];		p[++c]=s[i];	&#125;	disc(c);	for(int i=1;i&lt;=n;i++)	k[query(a[i])]++;//暴力统计	for(int i=1;i&lt;=m;i++)	&#123;		int x=k[query(w[i])];		int y=k[query(s[i])];		if(x&gt;ans1||(x==ans1&amp;&amp;y&gt;ans2))		&#123;			ans=i;			ans1=x;			ans2=y;		&#125;	&#125;	cout&lt;&lt;ans&lt;&lt;endl;	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】[HNOI2003]激光炸弹</title>
    <url>/2019/08/05/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-HNOI2003-%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9/</url>
    <content><![CDATA[【解题报告】 [HNOI2003]激光炸弹
题目：luogu P2280
在这样可爱的夜晚，调试题目恐怕是最爽的选择了
附：https://www.luogu.org/record/list?user=136889
在这么多次失败下我终于成功了
解题思路：
前缀和与拆分
这是一道简单题，但是我却调试了那么多次没调出来，竟然是循环的问题
rp–。。
建立一个二维数组，储存某个区域的目标的数量，然后就使用一个二维前缀和，就可以弄出来了，注意因为时间的原因，在输入的时候也就直接输入了，我那么多次就是因为超时
AC代码
#include &lt;iostream&gt;using namespace std;const int maxn=5005;int r,n;int s[maxn][maxn];int ans;int x,y,w;int max(int a,int b)&#123;	return a&gt;b? a:b;&#125;int main()&#123;	cin&gt;&gt;n&gt;&gt;r;	for(int i=1;i&lt;=n;i++)	&#123;		cin&gt;&gt;x&gt;&gt;y&gt;&gt;w; 		s[x+1][y+1]=w;	&#125;	for(int i=1;i&lt;=5001;i++)	&#123;		for(int j=1;j&lt;=5001;j++)		s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];	&#125;	for(int i=0;i&lt;=5001-r;i++)	&#123;		for(int j=0;j&lt;=5001-r;j++)		ans=max(ans,s[i][j]-s[i+r][j]-s[i][j+r]+s[i+r][j+r]); 	&#125;	cout&lt;&lt;ans&lt;&lt;endl;	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 CH0501 货仓选址</title>
    <url>/2019/08/07/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-CH0501-%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/</url>
    <content><![CDATA[【解题报告】 CH0501 货仓选址
题目：货仓选址
解题思路：
中位数
中位数是一种美好的数，在数学中经常使用，这道题建立一个数组，读入数据，然后排序一下，假设货仓建在x处，x左边有p个商家，x右边有q个商家，如果p&lt;q,那么把货仓向右移一个位置，距离之和就变小，类似地，p&gt;q，就把货仓向左移一个位置，所以建在中间的时候距离之和最小
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=100005;int a[maxn],n,ans,pos;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)    cin&gt;&gt;a[i];    sort(a+1,a+1+n);    int pos=a[n/2+1];    for(int i=1;i&lt;=n;i++)    ans+=abs(a[i]-pos);    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】[NOI2002]银河英雄传说</title>
    <url>/2019/08/04/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-NOI2002-%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4/</url>
    <content><![CDATA[【解题报告】[NOI2002]银河英雄传说
题目：luogu P1196

题意简述
处理M个指令，都为两种如下形式的指令之一
1.M i j 表示让第i好战舰所在列的全部战舰保持原有顺序，接在第j好战舰所在列的尾部。
2.C i j，表示询问第i号战舰与第j号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。如果不在同一列中，输出-1；
解题思路
并查集
第二个指令我们要知道i，j两号战舰差多少，维护一个数列d即可，d[x]代表x前面的战舰数量,要查询的时候，我们只要知道i，j两号前面各有多少战舰，然后i前面的减去j前面的绝对值减一就可以了。
而第一个指令就是简单地处理一下size，记录集合大小，也很简单
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int f[30005];int d[30005];int size[30005];int t;int jdz(int x)&#123;	return x&gt;0? x:(-x);&#125;void init()&#123;	for(int i=1;i&lt;=30000;i++)	&#123;		f[i]=i;		size[i]=1;	&#125;&#125;int get(int x)&#123;	if(x==f[x])	return x;	int root=get(f[x]);	d[x]+=d[f[x]];	return f[x]=root;&#125;void merge(int x,int y)&#123;	x=get(x),y=get(y);	f[x]=y;d[x]=size[y];	size[y]+=size[x];&#125;int main()&#123;	cin&gt;&gt;t;	init();	for(int i=1;i&lt;=t;i++)	&#123;		char s[2];		int x,y;		scanf(&quot;%s&quot;,s);		cin&gt;&gt;x&gt;&gt;y;		if(s[0]==&#x27;M&#x27;)		merge(x,y);		if(s[0]==&#x27;C&#x27;)		&#123;			if(get(x)==get(y))			cout&lt;&lt;jdz(d[x]-d[y])-1&lt;&lt;endl;			else			cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;		&#125;	&#125;	return 0;&#125;
数据情况https://www.luogu.org/record/22153408
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 [NOIP2012] 国王游戏</title>
    <url>/2019/08/10/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-NOIP2012-%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[【解题报告】 [NOIP2012]国王游戏
题目：国王游戏
解题思路：
贪心
我们只需要将所有大臣左右手上的数的乘积从小到大进行排序，我们就得到了最优答案，但是这个代码要写高精度就是一个麻烦的东西，要好好写，话说近几年不出高精度的题目了，就怕今年要出。
AC代码
#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn=10005;int n;struct mini&#123;	int a;	int b;&#125;m[maxn];bool cmp(mini x,mini y)&#123;	return x.a*x.b&lt;y.a*y.b;&#125;int s[4005],len;int ans[4005],ans_l(0); void mul(int x)&#123;	int t(len);	for(int i=1;i&lt;=len;++i)	s[i]*=x;	for(int i=1;i&lt;=len+5;++i)	&#123;		if(s[i])		t=i;		s[i+1]+=s[i]/10;		s[i]%=10;	&#125;	len=t;&#125;void cpy(int c[],int c_l)&#123;	for(int i=1;i&lt;=c_l;++i)	ans[i]=c[i];	ans_l=c_l;&#125;void out(int s[],int l)&#123;	for(int i=l;i&gt;=1;--i)	cout&lt;&lt;s[i];	cout&lt;&lt;endl; &#125;void div(int x)&#123;	int c[4005],l(-1);	for(int i=1;i&lt;=len;++i)	c[i]=s[i];	for(int i=len;i&gt;=1;--i)	&#123;		c[i-1]+=(c[i]%x)*10;		c[i]/=x;		if(c[i]&amp;&amp;l==-1)		l=i;	&#125;	if(ans_l==l)	&#123;		bool flg(0);		for(int i=l;i&gt;=1;--i)		&#123;			if(ans[i]&lt;c[i])			&#123;				flg=1;				break;			&#125;			else break;		&#125;		if(flg)		cpy(c,l);	&#125;	if(ans_l&lt;l)	cpy(c,l);&#125;int main()&#123;	cin&gt;&gt;n;	cin&gt;&gt;m[0].a&gt;&gt;m[0].b;	for(int i=1;i&lt;=n;++i)	cin&gt;&gt;m[i].a&gt;&gt;m[i].b;	sort(m+1,m+1+n,cmp);	s[1]=1;len=1;	mul(m[0].a);	for(int i=1;i&lt;=n;++i)	div(m[i].b),mul(m[i].a);	out(ans,ans_l);	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 POJ1050 To the Max</title>
    <url>/2019/08/18/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-POJ1050-To-the-Max/</url>
    <content><![CDATA[【解题报告】 POJ1050 To the Max
题目：最大的和（已翻译）
题意简述：
就是一个矩阵中找一个和最大的子矩阵
解题思路：
贪心，我们可以首先在输入的时候贪一遍心，然后我们可以一行一行地贪心，最终得到最后的正确结果
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=105;int n;int a[maxn][maxn],s[maxn][maxn];int ans=-0x3f,nans;bool check=false;int max(int a,int b)&#123;	return a&gt;b? a:b;&#125;int main()&#123;	cin&gt;&gt;n;	for(int i=1;i&lt;=n;i++)	&#123;		for(int j=1;j&lt;=n;j++)		&#123;			cin&gt;&gt;a[i][j];			if(a[i][j]&gt;=0)			check=true;			ans=max(ans,a[i][j]);		&#125;	&#125;	if(!check)	&#123;		cout&lt;&lt;ans&lt;&lt;endl;		return 0;	&#125;	for(int i=1;i&lt;=n;i++)	&#123;		for(int j=1;j&lt;=n;j++)		s[i][j]=s[i-1][j]+a[i][j];	&#125;	for(int i=1;i&lt;=n;i++)	&#123;		for(int j=i;j&lt;=n;j++)		&#123;			nans=0;			for(int k=1;k&lt;=n;k++)			&#123;				nans+=s[j][k]-s[i-1][k];				if(nans&lt;0)				nans=0;				if(nans&gt;ans)				ans=nans;			&#125;		&#125;	&#125;	cout&lt;&lt;ans&lt;&lt;endl;	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 POJ1328 雷达设备</title>
    <url>/2019/08/10/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-POJ1328-%E9%9B%B7%E8%BE%BE%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[【解题报告】 POJ1328 雷达设备
题目：雷达设备（已翻译）
解题思路：
贪心。
这道题只需要将x轴上方的一些建筑物，利用勾股定理算出x轴上一段能管辖它的区间，所以问题就变成了给定n个区间，在x轴上放置最少的点，使每个区间至少包含一个点，但是，特别地，如果建筑物的纵坐标超出了每个雷达管辖的半径，就直接不会继续下去了，因为不管怎么样，那个建筑物都无法被管辖，所以我们只需要每个建筑物算出来的区间的右端点进行排序，然后设置一个数组vis，来记录每个建筑物是否被管辖到，然后就ok了
AC代码
#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn=1005;int n,d;int ans;bool vis[maxn];struct sec&#123;	double l;	double r;&#125;b[maxn];bool cmp(sec p,sec q)&#123;	return p.r&lt;q.r;&#125;int main()&#123;	cin&gt;&gt;n&gt;&gt;d;	for(int i=1;i&lt;=n;i++)	&#123;		int x,y;		cin&gt;&gt;x&gt;&gt;y;		y=abs(y);		if(y&gt;d)		&#123;			cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;			return 0;		&#125;		b[i].l=x-sqrt(d*d-y*y);		b[i].r=x+sqrt(d*d-y*y);		vis[i]=false;	&#125;	sort(b+1,b+1+n,cmp);	for(int i=1;i&lt;=n;i++)	&#123;		if(!vis[i])		&#123;			ans++;			vis[i]=true;			for(int j=i+1;j&lt;=n;j++)			&#123;				if(b[j].l&lt;b[i].r)				vis[j]=true;			&#125;		&#125;	&#125;	cout&lt;&lt;ans&lt;&lt;endl;	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 POJ1958 奇怪的汉诺塔</title>
    <url>/2019/07/28/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-POJ1958-%E5%A5%87%E6%80%AA%E7%9A%84%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    <content><![CDATA[【解题报告】 POJ1958 奇怪的汉诺塔

在这样热浪滚滚的暑假，外面晴空高照，在家里刷刷题不妨是最好的选择
——来自wweiyi语录

题目链接（翻译过的）：
https://www.acwing.com/problem/content/98/
题意简述：输出四个塔的汉诺塔分别从1个盘子到12个盘子的最少步数

我们看了题之后，可以知道这道题跟三个塔的汉诺塔一样，用递归，但是我们设先移走i个盘子到第二个塔或第三个塔，然后就转化成三个塔的问题了。
但是问题在于不知道i等于多少，而且直接输出12个值要用递归也会有些慢，所以我们做一下优化，记忆化一下，我们就可以很快的输出了
设三个塔n个盘子的步数为d[n],设四个塔n个盘子的步数为f[n]
动态转移方程如下
fn=min(fn,2fi+dn−i)f_n=min(f_n,2f_i+d_{n-i})
fn​=min(fn​,2fi​+dn−i​)
其中
1≤n,i≤121\leq n,i \leq 12
1≤n,i≤12
所以我们就解决了这道题目
代码如下
#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int d[15];int f[15];int min(int a,int b)//最小值函数&#123;	return a&lt;b? a:b;&#125;int main()&#123;	d[1]=1;//汉诺三塔边界	for(int i=2;i&lt;=12;i++)//计算汉诺三塔的数值	d[i]=2*d[i-1]+1;	memset(f,0x3f,sizeof f);//因为要求最小值，所以初始一个极大值	f[1]=1;//汉诺四塔边界	for(int i=2;i&lt;=12;i++)//动态规划	&#123;		for(int j=1;j&lt;i;j++)		&#123;			f[i]=min(f[i],2*f[j]+d[i-j]);//状态转移方程		&#125;	&#125;	for(int i=1;i&lt;=12;i++)	cout&lt;&lt;f[i]&lt;&lt;endl;//输出	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 POJ2299 超快速排序</title>
    <url>/2019/08/08/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-POJ2299-%E8%B6%85%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[【解题报告】POJ2299 超快速排序
题目：超快速排序（已翻译）
解题思路：
归并排序求逆序对
归并排序使我们众所周知的，我们只要在归并排序中计算每一个子序列中的逆序对数，我们就可以计算出总的逆序对数了，也就是
cnt+=mid−i+1cnt+=mid-i+1
cnt+=mid−i+1
然后就完成了这道题
AC代码
#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n;long long cnt;const int maxn=500005;long long a[maxn];long long b[maxn];void merge_sort(int l,int r)&#123;    if(r&gt;l)    &#123;        int mid=(l+r)/2;        int i=l;         int p=l,q=mid+1;        merge_sort(l,mid);        merge_sort(mid+1,r);        while(p&lt;=mid||q&lt;=r)        &#123;            if(q&gt;r||(p&lt;=mid&amp;&amp;a[p]&lt;=a[q]))            b[i++] = a[p++];            else            &#123;                b[i++]=a[q++];                cnt+=mid-p+1;            &#125;        &#125;        for(i=l;i&lt;=r;i++)        a[i]=b[i];    &#125;&#125;int main()&#123;	while(cin&gt;&gt;n&amp;&amp;n)	&#123;		for(int i=1;i&lt;=n;i++)		cin&gt;&gt;a[i];		cnt=0;		merge_sort(1,n);		cout&lt;&lt;cnt&lt;&lt;endl;	&#125;	return 0;&#125;
顺便附上归并排序的代码
#include &lt;iostream&gt;using namespace std;int n,cnt;const int maxn=100005;long long a[maxn];long long b[maxn];void merge_sort(int l,int r)&#123;    if(r&gt;l)    &#123;        int mid=(l+r)/2;        int i=l;         int p=l,q=mid+1;        merge_sort(l,mid);        merge_sort(mid+1,r);        while(p&lt;=mid||q&lt;=r)        &#123;            if(q&gt;r||(p&lt;=mid&amp;&amp;a[p]&lt;=a[q]))            b[i++] = a[p++];            else            &#123;                b[i++]=a[q++];                cnt+=mid-p+1;            &#125;        &#125;        for(i=l;i&lt;=r;i++)        a[i]=b[i];    &#125;&#125;int main()&#123;	cin&gt;&gt;n;	for(int i=1;i&lt;=n;i++)	cin&gt;&gt;a[i];	merge_sort(1,n);	for(int i=1;i&lt;=n;i++)	&#123;		cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;	&#125;	cout&lt;&lt;endl;	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 POJ2054 给树染色</title>
    <url>/2019/08/10/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-POJ2054-%E7%BB%99%E6%A0%91%E6%9F%93%E8%89%B2/</url>
    <content><![CDATA[【解题报告】 POJ2054 给树染色
题目：Color a tree(已翻译)
解题思路：
贪心
我们很容易想到从第一层开始，每次染权值最大的一个节点，但是我们可以构造出一个数，让一个权值很小的点下面有权值很大的节点，所以我们考虑的贪心思路是树中除了根节点外的权值最大的节点，它的父节点染色之后一定会被马上染色，所以我们可以将权值最大的点和它的父节点进行合并，合并得到的新点的权值是这两个点之和的平均值，这样就一直合并，直至合并到一个点的时候，我们就按照这个点合并的顺序染色就是正确的答案了。
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;long long r,n;long long i,j,now,ans,a,b,father;struct node&#123;	long long f,c,t;	double w;&#125;num[1010];long long find()&#123;	long long ans=0;	double maxn=0;	for(int i=1;i&lt;=n;i++)	&#123;		if(i!=r&amp;&amp;num[i].w&gt;maxn)		&#123;			maxn=num[i].w;			ans=i;		&#125;	 &#125; 	 return ans;&#125;int main()&#123;	while(cin&gt;&gt;n&gt;&gt;r&amp;&amp;(n||r))	&#123;		ans=0;		for(int i=1;i&lt;=n;i++)		&#123;			cin&gt;&gt;num[i].c;			num[i].w=num[i].c;			num[i].t=1;			ans+=num[i].c;		&#125;		for(int i=1;i&lt;=n-1;i++)		&#123;			cin&gt;&gt;a&gt;&gt;b;			num[b].f=a;		&#125;		for(int i=1;i&lt;=n-1;i++)		&#123;			now=find();			num[now].w=0;			father=num[now].f;			ans+=num[now].c*num[father].t;			for(int j=1;j&lt;=n;j++)			&#123;				if(num[j].f==now)				num[j].f=father;			&#125;			num[father].c+=num[now].c;			num[father].t+=num[now].t;			num[father].w=(double)(num[father].c)/num[father].t;		&#125;		cout&lt;&lt;ans&lt;&lt;endl;	&#125;	return 0;&#125;
PS:LYD的代码有毒，在洛谷上过得了，但是在AcWing上过不了，所以我进行了摸爬滚打，终于找到了正确的答案，哈哈哈，我太开心了
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 POJ3614 防晒</title>
    <url>/2019/08/09/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-POJ3614-%E9%98%B2%E6%99%92/</url>
    <content><![CDATA[【解题报告】 POJ3614 防晒
题目：防晒（已翻译）
解题思路：
模拟+贪心；
我们这道题是一道好的贪心的例题，我们只要对于每一头奶牛按照它们的minspf进行递减排序，然后在对于每一种防晒霜进行一次扫描，找出符合条件的spf值最大的防晒霜
但是会想到一点，我们需要将每一头奶牛的minspf和maxspf进行一一对应，所以我们可以使用结构体，然后自己在写一个比较函数，就可以让这两个数值一一对应，这样就方便多了
AC代码
#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=2505;int c,l,ans;struct cow&#123;	int minspf;	int maxspf;&#125;a[maxn];struct sc&#123;	int spf;	int cover;&#125;b[maxn];int cmp(sc a,sc b)&#123;    if(a.spf==b.spf)    return a.cover&gt;b.cover;    return a.spf&gt;b.spf;&#125;int cmp2(cow a,cow b)&#123;    if(a.minspf==b.minspf)    return a.maxspf&gt;b.maxspf;    return a.minspf&gt;b.minspf;&#125;int main()&#123;	cin&gt;&gt;c&gt;&gt;l;	for(int i=1;i&lt;=c;i++)	cin&gt;&gt;a[i].minspf&gt;&gt;a[i].maxspf;	sort(a+1,a+1+c,cmp2);	for(int i=1;i&lt;=l;i++)	cin&gt;&gt;b[i].spf&gt;&gt;b[i].cover;	sort(b+1,b+1+l,cmp);	for(int i=1;i&lt;=c;i++)	&#123;		for(int j=1;j&lt;=l;j++)		&#123;			if(b[j].spf&gt;=a[i].minspf&amp;&amp;b[j].spf&lt;=a[i].maxspf&amp;&amp;b[j].cover)			&#123;				ans++;				b[j].cover--;				break;			&#125;		&#125;	&#125;	cout&lt;&lt;ans&lt;&lt;endl;	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 Stick</title>
    <url>/2019/08/25/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-Stick/</url>
    <content><![CDATA[【解题报告】 Stick
题目：木棍
解题思路：
深度优先搜索
我们可以用深度优先搜索简单地做出来，没错，是很简单
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int a[100],v[100],n,len,cnt;bool cmp(int a,int b)&#123;	return a&gt;b;&#125;bool dfs(int stick,int cab,int last)&#123;	if(stick&gt;cnt)	return true;	if(cab==len)	return dfs(stick+1,0,1);	int fail=0;	for(int i=last;i&lt;=n;i++)	&#123;		if(!v[i]&amp;&amp;cab+a[i]&lt;=len&amp;&amp;fail!=a[i])		&#123;			v[i]=1;			if(dfs(stick,cab+a[i],i+1))			return true;			fail=a[i];			v[i]=0; 			if(cab==0||cab+a[i]==len)			return false;		&#125;	&#125;	return false;&#125;int main()&#123;	while(cin&gt;&gt;n&amp;&amp;n)	&#123;		int sum=0,val=0,m=0;		for(int i=1;i&lt;=n;i++)		&#123;			int x;			cin&gt;&gt;x;			if(x&lt;=50)			&#123;				a[++m]=x;				sum+=a[m];				val=max(val,a[m]);			&#125;		&#125;		n=m;		sort(a+1,a+1+n,cmp);		for(len=val;len&lt;=sum;len++)		&#123;			if(sum%len)			continue;			cnt=sum/len;			memset(v,0,sizeof(v));			if(dfs(1,0,1))			break;		&#125;		cout&lt;&lt;len&lt;&lt;endl;	&#125;	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 占卜DIY</title>
    <url>/2019/08/18/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-%E5%8D%A0%E5%8D%9CDIY/</url>
    <content><![CDATA[【解题报告】 占卜DIY
题目：占卜DIY
解题思路：
简简单单的模拟加上dfs（简单的dfs）
但是这个游戏还是挺有意思的，可以看一下

一副去掉大小王的扑克共52张，打乱后均分为13堆，编号1~13，每堆4张，其中第13堆称作“生命牌”，也就是说你有4条命。
这里边，4张K被称作死神。
初始状态下，所有的牌背面朝上扣下。
流程如下：
1.抽取生命牌中的最上面一张(第一张)。
2.把这张牌翻开，正面朝上，放到牌上的数字所对应编号的堆的最上边。(例如抽到2，正面朝上放到第2堆牌最上面，又比如抽到J，放到第11堆牌最上边，注意是正面朝上放)
3.从刚放了牌的那一堆最底下(最后一张)抽取一张牌，重复第2步。（例如你上次抽了2，放到了第二堆顶部，现在抽第二堆最后一张发现是8，又放到第8堆顶部…）
4.在抽牌过程中如果抽到K，则称死了一条命，就扔掉K再从第1步开始。
5.当发现四条命都死了以后，统计现在每堆牌上边正面朝上的牌的数目，只要同一数字的牌出现4张正面朝上的牌(比如4个A)，则称“开了一对”，当然4个K是不算的。
6.统计一共开了多少对，开了0对称作”极凶”，1~2对为“大凶”，3对为“凶”，4~5对为“小凶”，6对为“中庸”，7~8对“小吉”，9对为“吉”，10~11为“大吉”，12为“满堂开花，极吉”。

这个游戏还是比较高级的
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int po[60][60];int d[60][60];int s[60];void init()&#123;	for(int i=1;i&lt;=13;i++)	&#123;		for(int j=1;j&lt;=4;j++)		&#123;			char p=getchar();			if(p&gt;=&#x27;2&#x27;&amp;&amp;p&lt;=&#x27;9&#x27;)			po[i][j]=p-&#x27;0&#x27;;			if(p==&#x27;0&#x27;)			po[i][j]=10;			if(p==&#x27;J&#x27;)			po[i][j]=11;			if(p==&#x27;Q&#x27;)			po[i][j]=12;			if(p==&#x27;K&#x27;)			po[i][j]=13;			if(p==&#x27;A&#x27;)			po[i][j]=1;			getchar();		&#125;		d[i][5]=5;	&#125;&#125;void dfs(int x)&#123;	if(x==13)	return ;	d[x][++d[x][0]]=x;	int cx=po[x][--d[x][5]];	dfs(cx);&#125;void sum()&#123;	for(int i=1;i&lt;=13;i++)	&#123;		for(int j=1;j&lt;=4;j++)		&#123;			if(d[i][j])			s[d[i][j]]++;		&#125;	&#125;	int ans=0;	for(int i=1;i&lt;=13;i++)	&#123;		if(s[i]==4)		ans++;	&#125;	cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;	init();	for(int i=1;i&lt;=4;i++)	dfs(po[13][i]);	sum();	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 天才ACM</title>
    <url>/2019/08/09/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-%E5%A4%A9%E6%89%8DACM/</url>
    <content><![CDATA[【解题报告】 天才ACM
题目：天才ACM
解题思路：
倍增算法
设p=1，r=l
求出r—r+p这一区间的校验值，如果校验值小于等于t，则r+=p，p*=2；
否则p/=2;
一直重复，直到p等于0的时候，r就是最终答案
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=500005;long long t,tot;long long n,m,k;long long p[maxn];long long f[maxn];int l,r,mid,j;long long min(long long a,long long b)&#123;	return a&lt;b? a:b;&#125;bool check(int l,int r) &#123;    tot=0;    long long sum=0;    for(int i=l;i&lt;=r;i++) 	f[++tot]=p[i];    sort(f+1,f+1+tot);    for(int i=1;i&lt;=m;i++) 	&#123;        if (i&gt;=(tot-i+1)) 		break;        sum+=(long long)(f[tot-i+1]-f[i])*(f[tot-i+1]-f[i]);        if(sum&gt;k)		break;    &#125;    if(sum&gt;k)	return false;    return true;&#125;bool cmp(int x,int y)&#123;	return p[x]&lt;p[y];&#125;bool calc()&#123;	long long sum=0;	int ll=1,rr=tot;	for(int i=1;i&lt;=m;i++)	&#123;		while(ll&lt;rr&amp;&amp;f[ll]&gt;mid)		ll++;		while(ll&lt;rr&amp;&amp;f[rr]&gt;mid)		rr--;		if(ll&gt;=rr)		break;		sum+=(long long)(p[f[rr]]-p[f[ll]])*(p[f[rr]]-p[f[ll]]);		if(sum&gt;k)		break;		ll++;		rr--;	&#125;	return sum&lt;=k;&#125;void work()&#123;		cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;		for(int i=1;i&lt;=n;i++)		cin&gt;&gt;p[i];		int ans=0;		for(int i=1;i&lt;=n;i++)		&#123;			for(j=1;i+(1&lt;&lt;j)-1&lt;=n;j++)			&#123;				if(!check(i,i+(1&lt;&lt;j)-1))				break;			&#125;			l=i+(1&lt;&lt;(j-1))-1;			r=min(i+(1&lt;&lt;j)-1,n);			tot=0;			for(int k=i;k&lt;=r;k++)			f[++tot]=k;			sort(f+1,f+tot+1,cmp);			while(l&lt;=r)			&#123;				mid=(l+r)/2;				if(calc())				&#123;					i=mid;					l=mid+1;				&#125;				else r=mid-1;			&#125;			ans++;		&#125;		cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;	cin&gt;&gt;t;	while(t--)	&#123;		work();	&#125;	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 Task</title>
    <url>/2019/08/18/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-Task/</url>
    <content><![CDATA[【解题报告】 Task
题目：任务
解题思路：
贪心
我们可以贪心每个任务的等级，再贪心每个任务的时间，我们这样排一下序，再循环一下，就可以得到正确的答案了
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const long long maxn=100010;long long n,m;struct task&#123;	long long x;	long long y;&#125;; task f[maxn];task e[maxn];long long cnt[105],ans,num;long long cmp(task a,task b)&#123;	if(a.x==b.x)	return a.y&gt;b.y;	return a.x&gt;b.x;&#125;int main()&#123;	cin&gt;&gt;n&gt;&gt;m;	for(long long i=1;i&lt;=n;i++)	cin&gt;&gt;e[i].x&gt;&gt;e[i].y;	for(long long i=1;i&lt;=m;i++)	cin&gt;&gt;f[i].x&gt;&gt;f[i].y;	sort(e+1,e+1+n,cmp);	sort(f+1,f+1+m,cmp);	long long j=1;	for(long long i=1;i&lt;=m;i++)	&#123;		while(j&lt;=n&amp;&amp;e[j].x&gt;=f[i].x)		&#123;			cnt[e[j].y]++;			j++;		&#125;		for(long long k=f[i].y;k&lt;=100;k++)		&#123;			if(cnt[k])			&#123;				num++;				cnt[k]--;				ans+=500*f[i].x+2*f[i].y;				break;			&#125;		&#125;	&#125;	cout&lt;&lt;num&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;	return 0; &#125;
PS：实在不懂为什么别人的代码要用pair
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 士兵</title>
    <url>/2019/08/18/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-%E5%A3%AB%E5%85%B5/</url>
    <content><![CDATA[【解题报告】 士兵
题目：士兵
解题思路：
排序+离散化
我们可以对每个士兵的纵坐标和横坐标进行排序，然后算它们的中位数，就可以得到他们最短的路线，然后就可以对每个士兵和中位数做差，用一个变量记录它们的和，即为答案
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn=10005;int n;long long x[maxn],y[maxn],mx,my,ans;int main()&#123;	cin&gt;&gt;n;	for(int i=1;i&lt;=n;i++)	cin&gt;&gt;x[i]&gt;&gt;y[i];	sort(x+1,x+1+n);	sort(y+1,y+1+n);	for(int i=1;i&lt;=n;i++)	x[i]-=i;	sort(x+1,x+1+n);	mx=x[(n+1)&gt;&gt;1];	my=y[(n+1)&gt;&gt;1];	for(int i=1;i&lt;=n;i++)	&#123;		ans+=abs(x[i]-mx);		ans+=abs(y[i]-my);	&#125;	cout&lt;&lt;ans&lt;&lt;endl;	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 小猫爬山</title>
    <url>/2019/08/23/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-%E5%B0%8F%E7%8C%AB%E7%88%AC%E5%B1%B1/</url>
    <content><![CDATA[【解题报告】 小猫爬山
题目：小猫爬山
解题思路：
哪家会养这么重又这么多猫，只能说他们两个比较闲的无聊
当然这道题就像猫一样，特别狡猾
开始的时候我看到这个，想到了一个贪心做法，但是不管怎么改，答案就是改不对，经过前思后想，左顾右盼，我知道了真正的算法：搜索+剪枝
恰好就是我不最擅长的算法！
我就按照思路和书中所给的部分代码打出来了，当我提交上去的时候，一个大大的A字亮在我的眼前，没错
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int c[20],cab[20],n,w,ans;void dfs(int now,int cnt)&#123;	if(cnt&gt;=ans)	return ;	if(now==n+1)	&#123;		ans=min(ans,cnt);		return ;	&#125;	for(int i=1;i&lt;=cnt;i++)	&#123;		if(cab[i]+c[now]&lt;=w)		&#123;			cab[i]+=c[now];			dfs(now+1,cnt);			cab[i]-=c[now];		&#125;	&#125;	cab[cnt+1]=c[now];	dfs(now+1,cnt+1);	cab[cnt+1]=0;&#125;bool cmp(int a,int b)&#123;	return a&gt;b;&#125;int main()&#123;	cin&gt;&gt;n&gt;&gt;w;	for(int i=1;i&lt;=n;i++)	cin&gt;&gt;c[i];	sort(c+1,c+1+n,cmp);	ans=n;	dfs(1,0);	cout&lt;&lt;ans&lt;&lt;endl;	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 耍杂技的牛</title>
    <url>/2019/08/23/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-%E8%80%8D%E6%9D%82%E6%8A%80%E7%9A%84%E7%89%9B/</url>
    <content><![CDATA[【解题报告】 耍杂技的牛
题目：耍杂技的牛
解题思路：
排序+贪心
这个牛啊实际上就是大臣，约翰那就是国王，你有没有想到一道题目，没错，那就是《国王游戏》，但是没错，那道题需要高精度，这道题目不需要高精度，所以这道题目就简单多了，这道题就是按（w+s）把牛牛们从小到大排序一下，然后计算出它们的风险值，找出最大的就可以了，还是比较简单的
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=50010;long long n;long long d[maxn];long long res=-0x3f3f3f3f,sum=0;struct cow&#123;	long long w;	long long s;&#125;a[maxn];bool cmp(cow a,cow b)&#123;	return a.s+a.w&lt;b.s+b.w;&#125;int main()&#123;	cin&gt;&gt;n;	for(int i=1;i&lt;=n;i++)	cin&gt;&gt;a[i].w&gt;&gt;a[i].s;	sort(a+1,a+n+1,cmp);    for(int i=1;i&lt;=n;i++)	&#123;        res=max(res,sum-a[i].s);        sum+=a[i].w;    &#125;    cout&lt;&lt;res&lt;&lt;endl;    return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】 防线</title>
    <url>/2019/08/23/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91-%E9%98%B2%E7%BA%BF/</url>
    <content><![CDATA[【解题报告】 防线
题目：防线
解题思路：
虽然说是解题报告，但是也是有一部分曲折在其中的，因为这道题开始的时候实在想不到思路，知道看到了某大佬的题解之后才豁然开朗，明白了这道题目的做法，和神奇的思想
这道题的思想很简单，就是用前缀和
你要想，奇数加奇数等于偶数，但是题目中只有一个是奇数的，所以这种情况不成立，那么就只有偶数加奇数或偶数加偶数两种情况
因此我们就做一个前缀和加上一个神奇而又简单的二分，就可以得出正确而又完美有缺的答案了（有缺我也不知道那里缺）
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=200005;int n,t;struct ar&#123;	long long s;	long long e;	long long d;&#125;a[maxn];long long judge(long long x)&#123;	long long ans=0;	for(int i=1;i&lt;=n;i++)	&#123;		if(a[i].s&lt;=x)		ans+=(min(x,a[i].e)-a[i].s)/a[i].d+1;	&#125;	return ans;&#125;int main()&#123;	cin&gt;&gt;t;	while(t--)	&#123;		cin&gt;&gt;n;		for(int i=1;i&lt;=n;i++)		cin&gt;&gt;a[i].s&gt;&gt;a[i].e&gt;&gt;a[i].d;		long long l=0,r=((long long)1&lt;&lt;31)-1;		while(l&lt;r)		&#123;			long long mid=(l+r)/2;			if(!(judge(mid)&amp;1))//如果这个min之前的是偶数 			l=mid+1;			else			r=mid;		&#125;		int ans=judge(r)-judge(r-1);		if(ans)		cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;		else		cout&lt;&lt;&quot;There&#x27;s no weakness.&quot;&lt;&lt;endl;	&#125;	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>为美好的世界献上祝福</title>
    <url>/2025/07/10/%E4%B8%BA%E7%BE%8E%E5%A5%BD%E7%9A%84%E4%B8%96%E7%95%8C%E7%8C%AE%E4%B8%8A%E7%A5%9D%E7%A6%8F/</url>
    <content><![CDATA[为美好的世界献上祝福
]]></content>
      <categories>
        <category>漫评</category>
      </categories>
  </entry>
  <entry>
    <title>【解题报告】luogu P2078朋友</title>
    <url>/2019/08/06/%E3%80%90%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E3%80%91luoguP2078%E6%9C%8B%E5%8F%8B/</url>
    <content><![CDATA[【解题报告】luogu P2078 朋友
题目：luogu P2078
题目思路：
并查集，C++ STL
有了C++stl容器，我们就high了，map可以处理数组下标为负的情况，然后男女朋友的关系的话，就分别统计每个公司有多少人有关系，取一个最小值就好了
AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;map&gt; using namespace std;map&lt;int,int&gt;f;int n,m,p,q;int fm,fh;int max(int a,int b)&#123;	return a&lt;b? a:b;&#125; int get(int x)&#123;	return f[x]=(x==f[x]? x:get(f[x]));&#125;void merge(int x,int y)&#123;	f[get(x)]=get(y);&#125;int main()&#123;	int x,y;	cin&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;q;	for(int i=(-1*m);i&lt;=n;i++)	f[i]=i;	for(int i=1;i&lt;=p+q;i++)	&#123;		cin&gt;&gt;x&gt;&gt;y;		merge(x,y);	&#125;	for(int i=1;i&lt;=n;i++)	&#123;		if(get(f[i])==get(1))		fm++;	&#125;	for(int i=(-1*m);i&lt;=-1;i++)	&#123;		if(get(f[i])==get(-1))		fh++; 	&#125;	cout&lt;&lt;max(fm,fh)&lt;&lt;endl;	return 0;&#125;
]]></content>
      <categories>
        <category>OI时期解题报告</category>
      </categories>
  </entry>
  <entry>
    <title>学习笔记 简单的amodb A%B Problem</title>
    <url>/2019/07/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AE%80%E5%8D%95%E7%9A%84amodb-A-B-Problem/</url>
    <content><![CDATA[【基础题目】A%B Problem
题目描述

C–语言是一种C的简化版，它仅有的三种运算符为++，–和==（没有=，+，-，*，/，%，&lt;,&gt;等任何其他运算符），也没有循环及goto语句，除此之外与C相同。使用C–编写一个函数int
mod(int a,int b)，计算a除以b的余数。
——来自wweiyi暑假集训

题意简述：只用++,–,==运算符和C++的其他功能来完成a%b的功能
提示：允许调用其他函数
这是一道神奇的题目，我想了大半天才想出来，甚至引来了老师的批评，接下来我说一说我的思路
这道题我们需要只用++,–,==和C++的其他功能来实现模运算，这个看起开似乎无法实现，因为不能够使用循环，因此，这道题的阴影加深了。
递归！循环的后裔！
这里我们不能用循环，也就是我们需要使用类似循环的一个过程，递归来解决问题，递归是一种很常用的解决问题的方法，将一个大问题转换成一个子问题也许模运算就可以这样解决了。
++，–，==三运算符！三符成虎！
我们要解决模运算首先要解决减法运算的问题，因为a%b，就是a一直减b，减到a小于b为止，因此，我们可以先解决减法运算。
代码如下
int jian(int a,int b)&#123;    if(b==0)        return a;    return jian(--a,--b);&#125;
这样就解决了减法运算；
但是顺便说一句，加法和乘法运算实际上也很简单，让我来把代码贴出来！
int add(int a,int b)&#123;    if(b==0)        return a;    return add(++a,--b);&#125;int cheng(int a,int b)&#123;    if(b==0)        return a;    return add(a,cheng(a,--b));&#125;
我们可以轻松地解决减法，乘法和加法，但是模运算我们还是不知道，怎么办呢？
判断！事情的转机？
我们再次理清一下思路，我们需要a一直减b，一直减到a小于b为止，也就是mod(a,b)=mod(a-b,b)，这就是神奇的递归式，就可以解决一部分问题，另一部分问题就是判断a小于b，我们可以a，b同时递减，看谁先到0，但由于这个问题的特殊性，当a=b时，需要特殊判断一下，因为一个数mod它的因数等于0，所以我们的思路就出来了，代码也就写出来了。
代码如下
#include &lt;iostream&gt;using namespace std;int pd(int a,int b)&#123;	if(a==b)	return 0;	if(a==0)	return 1;	if(b==0)	return 0;	return pd(--a,--b);&#125;int jian(int a,int b)&#123;	if(b==0)	return a;	return jian(--a,--b);&#125;int mod(int a,int b)&#123;	if(pd(a,b)==1)	return a;	return mod(jian(a,b),b);&#125;int main()&#123;	int a,b;	cin&gt;&gt;a&gt;&gt;b;	cout&lt;&lt;mod(a,b)&lt;&lt;endl;	return 0;&#125;//wweiyi费时3小时智造
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>【回忆录】到信息学一游</title>
    <url>/2025/07/09/%E5%88%B0%E4%BF%A1%E6%81%AF%E5%AD%A6%E4%B8%80%E6%B8%B8/</url>
    <content><![CDATA[【回忆录】到信息学一游
序章 夜来幽梦忽还乡
现在是2025年7月份的一个晚上，是大二的暑假，大学生活已然过半，我终于通过一个自己参照教程的方式配置好了属于自己的博客，兴致满满。在添加友情链接的时候，我想起了我在初三的时候就已经了解到的学长 DewDewDew 和 wjyyywjyyywjyyy ，于是找到他们的博客。在他们的博客中，其中置顶的就是他们的回忆录，也就是参加信息学竞赛的整个高中的心路历程，让我不由自主想起了自己的信息学竞赛的生活，有感而发，于是我也准备写一个自己的回忆录。如果说沙子写字，风轻轻一吹就能吹散，纸上面写字，稍微的烈火焚烧就能让踪迹悄然而逝，也许，写在网上，这份记忆才不会消失，成为一种永生的纪念（大概是有区块链？）。
那时的生活，说累也累，说苦也苦，但是不知为什么，我总是不由自主回忆起高中、初中的生活，回忆起那段信息学竞赛的日子，这大概是我人生中最特殊的经历之一。我不知道它对我的生活产生了多少的影响，然而它的确是不可缺少的。
第一章 自前而后的延续
我并不类似于 DewDewDew 和 wjyyywjyyywjyyy 学长一样，是从高中开始学的信息学竞赛，我开始学信息学竞赛是在初一的时候。那个时候的我刚从小学升上来，小学执行的是素质教育，因此每周都会有社团活动时间，我对计算机有兴趣，便参加了计算机相关社团，学习了许多计算机的基础知识，比如word、ppt、Excel、VB以及Scratch的使用，算是对编程有了初步的了解。其实我一开始并不打算学习信息学竞赛，而是想学VB，做着自己喜欢的程序，做出一些好玩的东西，用来取悦自己。然而，当时的电脑并不支持我去这么做。想要安装VB完整版本的我在10年代的电脑上根本没有什么操作空间，只有一步一卡的漫长等待。而六年级的暑假我又是在没有网络的老家度过，感受这淳朴的乡土情怀，只能玩着MC度日。比较有意思的是，在没有网络的日子里，我靠着局域网联机，竟然在游戏中搭建出一个不小的天地，后来我又通过命令方块建造了一个可以自由传送的城镇，也许编程的思想来自于那里。后来升上了初中，开始了第一次摸底测试，在全校学生中拿到了前五十名，于是乎不知道为何发了6000元作为奖励，至此，我的信息学奥赛之路似乎被开启了。
当时的电脑不行，我的家长于是就用这6000元给我买了一台台式机，这台台式机在现在看来配置不可谓不低，而且现在已经用起来很卡顿，但是对于当时的我来说，已经是一台非常流畅的机器了。拿到电脑了之后，我安装了VB完整版本，准备左手参考书，右手鼠标，两只手一起打键盘的时候，家长拿着两本厚厚的书出现了。
这两本书就是至今也脍炙人口的《信息学奥赛一本通》和《信息学奥赛一本通习题》，相信大多数自己入门，或者弱校起步的同学，竞赛启航的第一站便是这里。两本书放在了我的桌面上，家长跟我说，编程不仅仅可以使用VB编程，也可以使用C++对程序进行编写，相对于VB，C++在应用面上更广。而且，现在有信息学奥赛，省一就能获得不小的高考优惠，因此学这个竞赛也许是有好处的。小小的我有着大大的梦，像所有小朋友一样，年少时候的梦想很多都是当科学家，而当上首屈一指的科学家，就必须要考上清华大学、北京大学这两所中国的TOP2，小学时候成绩还算优异的我理所当然也有着这样的梦想。
因为初中是一所寄宿学校，在学校并没有机会接触电脑，所以追求的只有那文化课的好成绩，每到周末的时候，我一回家就会快速写完作业，然后开始那信息学竞赛的进程。因为是自主学习，而且每周都会有遗忘的时候，在初一上学期我便重复在那顺序分支循环等逻辑结构中循环。我当然也知道每周过去都会忘记一些东西，所以我每周也反复练习，渴求达到熟练。
然而初一上的期末，因为考试题目过于简单，自己马虎过多，考出了一个自己在高中时候也不怎么见过的排名。那是我第一次考出这么差的名次，然而当时的班主任倒是非常友善，”偶尔考不好无所谓的，找清楚原因”。在初中的第一个学期，我含着泪离开了学校，这时候信息学也一再耽搁，仅仅止步于顺序分支循环了。
在寒假的时候，也许是临近过年了，气氛逐渐喜庆起来，我也将期末考试的悲伤抛之脑后，在电脑上开始了新一轮的信息学竞赛练习。父母非常看好我，我从小便喜欢计算机，在小学获得了大大小小的有关计算机的各种奖项。特别有印象的是全国中小学生计算机表演赛，如果没记错的话，小学课文里那篇启发我计算机重要性的文章的事件也是同一个事件。邓主席说过：“计算机的普及要从娃娃抓起”。在这寒假中，我便去认真学习循环，一维数组，二维数组等，直到达到熟练为止。
时间恍然而过，白驹过隙一般寒假已经过去，这个时候意想不到的事情发生了：我们进行了重新分班！从素质教育的小学升上初中的我并不明白这样的含义，也觉得这样非常残酷。为什么我们这些学生就不能和一开始认识的同学安安稳稳共同陪伴三年呢，为什么非要把各个成绩好的学生集中在一起，而不是分开各领风骚呢。我第一次经历分班，我并不理解。但是我所做的，我能做的只有接受，那天晚上，原先的班主任跟我的父母电话打了好久，我却处在一种不自觉的震撼之中，没有情绪波动，内心仍然认为下个学期的周边还是那群同学，而我会在熟悉的环境中启程我的新的一个学期。
终于开学了，我来到了新的班级，尽管非常想念原来的同学和老师，但这也是我无可奈何的事情。我来到了初中最好的班级，这里高手如云，每个人似乎都跟自己一样厉害，甚至还有不少人比自己厉害的多。在原先的班级中待惯了，现在就会感受到不小的落差。幸亏在班级中又认识了不少新朋友，让我怀古的心情好了许多。
]]></content>
      <categories>
        <category>游记</category>
      </categories>
  </entry>
  <entry>
    <title>幂运算</title>
    <url>/2019/08/03/%E5%B9%82%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[幂运算
众所周知，在NOIP系列竞赛中，会考到许多优化，而这些许多优化是由一个个简单的优化组件而来的，使整个程序的优化尽可能地达到最大，用最少的时间和空间来实现正确代码，而幂运算作为其中的一个基本我今天就来总结一下，如有不足，以后也会加勘误and Update。
幂
普遍数学上幂的意义是一个数做自乘的运算，如a的b次方意思是b个a相乘，使表示上更加简便
普通幂
C++中普通幂的代码很容易实现，这是实现代码(基本实现代码)
#include &lt;iostream&gt;using namespace std;int main()&#123;    int a,b;    cin&gt;&gt;a&gt;&gt;b;    for(int i=2;i&lt;=b;i++)    a*=a;    cout&lt;&lt;a&lt;&lt;endl;    return 0;&#125;
快速幂
在普通幂中发现算很大的数的时候回非常地慢，我们就要想怎么优化，怎么优化呢，我们引入一组基本公式
ab=ab2∗ab2(b为偶数)a^b=a^{\frac{b}{2}}*a^{\frac{b}{2}}(b为偶数)
ab=a2b​∗a2b​(b为偶数)
ab=ab2∗ab2∗a(b为奇数)a^b=a^{\frac{b}{2}}*a^{\frac{b}{2}}*a(b为奇数)
ab=a2b​∗a2b​∗a(b为奇数)
我们发现这样可以利用递归解决子问题来快速地算出a的b次方，加速了运算
代码如下
#include &lt;iostream&gt;using namespace std;int a,b;int quick_pow(int a,int b)&#123;    if(b==0)        return 1;    int t=quick_pow(a,b/2);    if(b%2==1)        return t*t*a;    else        return t*t;&#125;int main()&#123;    cin&gt;&gt;a&gt;&gt;b;    cout&lt;&lt;quick_pow(a,b)&lt;&lt;endl;    return 0;&#125;
或者代码也可以这样
#include &lt;iostream&gt;using namespace std;int power(int a,int b,int p)&#123;	int ans=1%p;	while(b)	&#123;		if(b&amp;1)		ans=(long long)ans*a%p;		a=(long long)a*a%p;         b&gt;&gt;=1;	&#125;	return ans;&#125;int main()&#123;	int a,b,p;	cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;	cout&lt;&lt;power(a,b,p)&lt;&lt;endl;	return 0;	&#125; 
特殊情况下算2的n次幂可以直接
1&lt;&lt;n1&lt;&lt;n
1&lt;&lt;n
矩阵快速幂
矩阵快速幂是一个对于矩阵的快速幂
你还不知道什么是矩阵吗？（快速查看：矩阵）
矩阵快速幂是对于矩阵乘法的自己多次相乘的快速运算
和普通快速幂差不多，只是把‘*’换成了一个mul函数
代码如下
mat mul(mat x,mat y)&#123;	mat c;	for(int i=1;i&lt;=n;i++)	&#123;		for(int j=1;j&lt;=n;j++)		c.m[i][j]=0;	&#125;	for(int i=1;i&lt;=n;i++)	&#123;		for(int j=1;j&lt;=n;j++)		&#123;			for(int k=1;k&lt;=n;k++)			c.m[i][j]=(c.m[i][j]%mod+(x.m[i][k]*y.m[k][j])%mod)%mod;		&#125;	&#125;	return c;&#125;
因为要返回一个数组，所以为了方便，我们新建了一个结构体，也就是mat
struct mat&#123;    long long m[1005][1005];//用来存矩阵&#125;;
这样我们在写一个类似于普通快速幂的函数就成功解决问题了
类普通快速幂函数
mat pow(mat a,long long b)&#123;	mat ans=e;	while(b)	&#123;		if(b&amp;1)		ans=mul(ans,a);		a=mul(a,a);		b&gt;&gt;=1;	&#125;	return ans;&#125;
所以我们就做出来了，但是为了使整个矩阵能保持原样，这个说不清，自己去看单位矩阵，然后这就是一个巧妙的地方
for(int i=1;i&lt;=n;i++)	e.m[i][i]=1;
最后，矩阵快速幂的一道模板题发给大家

lgP3390【模板】矩阵快速幂
提交 25.45k
通过 8.58k
时间限制 1.00s
内存限制 125.00MB
题目背景
矩阵快速幂
题目描述
给定n*n的矩阵A，求A^k
输入格式
第一行，n,k
第2至n+1行，每行n个数，第i+1行第j个数表示矩阵第i行第j列的元素
输出格式
输出A^k
共n行，每行n个数，第i行第j个数表示矩阵第i行第j列的元素，每个元素模10^9+7
输入输出样例
输入 #1
2 11 11 1
输出 #1
1 11 1
说明/提示
n&lt;=100, k&lt;=10^12, |矩阵元素|&lt;=1000 算法：矩阵快速幂

AC代码
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn=1005;const int mod=1000000007; struct mat&#123;	long long m[maxn][maxn];&#125;;mat a,e;long long n,p;mat mul(mat x,mat y)&#123;	mat c;	for(int i=1;i&lt;=n;i++)	&#123;		for(int j=1;j&lt;=n;j++)		c.m[i][j]=0;	&#125;	for(int i=1;i&lt;=n;i++)	&#123;		for(int j=1;j&lt;=n;j++)		&#123;			for(int k=1;k&lt;=n;k++)			c.m[i][j]=(c.m[i][j]%mod+(x.m[i][k]*y.m[k][j])%mod)%mod;		&#125;	&#125;	return c;&#125;mat pow(mat a,long long b)&#123;	mat ans=e;	while(b)	&#123;		if(b&amp;1)		ans=mul(ans,a);		a=mul(a,a);		b&gt;&gt;=1;	&#125;	return ans;&#125;int main()&#123;	cin&gt;&gt;n&gt;&gt;p;	for(int i=1;i&lt;=n;i++)	&#123;		for(int j=1;j&lt;=n;j++)		cin&gt;&gt;a.m[i][j];	&#125;	for(int i=1;i&lt;=n;i++)	e.m[i][i]=1;a	mat s=pow(a,p);	for(int i=1;i&lt;=n;i++)	&#123;		for(int j=1;j&lt;=n;j++)		cout&lt;&lt;s.m[i][j]&lt;&lt;&quot; &quot;;		cout&lt;&lt;endl;	&#125;	return 0;&#125;
PS:在自己电脑上可能输出不了，但是在洛谷IDE上能正常运行啊
这就奇怪了，请问一下各位为什么
下集预告：单源最短路径的优化或矩阵的简单介绍
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>最大公约数的故事</title>
    <url>/2019/07/26/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[最大公约数的故事

最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。a，b的最大公约数记为（a，b），同样的，a，b，c的最大公约数记为（a，b，c），多个整数的最大公约数也有同样的记号。——来自《百度百科》

[^]: 两个数的最大公约数a，b一般用gcd（a，b）来表示，因此，我后文也会用gcd（ ， ）来表示两个数的最大公约数
最大公约数在计算机中也很常用，而对于这种数了解最深的非欧几里得莫属了！
欧几里得

欧几里得（英文：Euclid；希腊文：Ευκλειδης，约公元前330年—公元前275年），古希腊人，数学家，被称为“几何之父”。他最著名的著作《几何原本》是欧洲数学的基础，提出五大公设，欧几里得几何，被广泛的认为是历史上最成功的教科书。欧几里得也写了一些关于透视、圆锥曲线、球面几何学及数论的作品。——来自《百度百科》

特别是数论方面有很深的造诣，因此我们今天计算机中关于数论的东西有很可观的一部分来自欧几里得，所以我们在这里看一下最大公约数。
如何算最大公约数？
质因数分解法
这是一个好问题，最简单的方法是用质因数分解法
例如：gcd（24,21）
质因数分解得：
24=2 * 2 * 2 * 3
21=3 * 7
它们公共的因数有3，因此，它们的最大公约数是3；
这个办法我们需要用到质因数分解，质因数分解代码如下：
#include &lt;iostream&gt;using namespace std;bool first=true;void zyz(int n,int p)&#123;    if(n&gt;1)    &#123;        if(n%p==0)        &#123;            if(first)            &#123;                cout&lt;&lt;p;                first=false;            &#125;            else cout&lt;&lt;&quot; &quot;&lt;&lt;p;            zyz(n/p,p);        &#125;        else zyz(n/p+1);    &#125;&#125;int main()&#123;    int n;    cin&gt;&gt;n;    zyz(n,2);    cout&lt;&lt;endl;    return 0;&#125;//选自信息学奥赛课课通（C++）
更相减损法
但是这样寻找最大公约数太慢了，怎么办呢？
中国古代《九章算术》中有一种方法，称为“更相减损法”
方法是
gcd(a,b)=gcd(b,a−b)gcd(a,b)=gcd(b,a-b)
gcd(a,b)=gcd(b,a−b)
，这样一直递归下去，当b等于0是，a‘就是a，b的最大公约数。
但这种方法太慢了，有一种更好的方法，我们在下面介绍。
辗转相除法
辗转相除法是欧几里得算法，是求最大公约数最常见的方法，我们来看一看。
我们仔细观察更相减损法，可以发现，gcd（a,b）=gcd(b,a-b)中右边的那一项是一直减b的因此，我们可以联想到计算机中的mod运算(%)，这样效率就大大地加高了。
递推式
gcd(a,b)=gcd(b,a模b)gcd(a,b)=gcd(b,a模b)
gcd(a,b)=gcd(b,a模b)
所以我们就可以用递归快速求出最大公约数
代码如下
int gcd(int a,int b)&#123;    return b? gcd(b,a%b):a;&#125;
这样就完成了求最大公约数
惊现！求逆元！

如果：a×b≡1 (mod n)
那么：
a×m≡a×k (mod n)
=&gt; b×a×m≡b×a×k (mod n)
=&gt; m≡k (mod n)
前提是b存在！
b称为a模n的逆元（a也是b模n的逆元）
x模n的逆元也记作
x−1(mod(n))x^{-1}(mod  (n))
x−1(mod(n))
——来自wweiyi的暑假集训

这样就可以放心地使用同余中的除法运算了，是不是很帅？？？
因为一个数%n的余数只有可能是0~n-1，又因为0不可能是一个数在模n意义下的逆元，所以我们可以枚举求逆元（From 1 to n-1） 所以，我们可以这样求
代码如下：
#include &lt;iostream&gt;using namespace std;int main()&#123;    int a,b,n;    cin&gt;&gt;a&gt;&gt;n;//表示求a在模n意义下的逆元    for(int i=1;i&lt;=n-1;i++)    &#123;        if((a*i)%n==1)        &#123;            b=i;break;        &#125;    &#125;    cout&lt;&lt;b&lt;&lt;endl;    return 0;&#125;
b就是a在模n意义下的乘法逆元，但是我们看下面一个例子：

例如：11模7的逆元
  	(11,7) 	  (a,b)
  	
  	(7,4) 		(b,a-b)
  	
  	(4,3)         (a-b,2b-a)
  	
  	(3,1)         (2b-a,**2a-3b**)
  	
  	即：2×11-3×7=1
  	
  	2×11≡1 (mod 7)
  	
  	∴11模7的逆元是2

——来自wweiyi暑假集训

有没有发现，这个就是gcd(11,7)的过程，只不过右边用字母代替了它的运算，但实际上是一样的，而到最后一步时，后边加粗的a的系数就是11模7的逆元！是不是很神奇！
所以我们就有了又快又简便的方法来求逆元
代码如下
#include&lt;bits/stdc++.h&gt;using namespace std;int b,x,y,mod,gcd; inline int exgcd(int a,int b,int &amp;x,int &amp;y)&#123;    if(b==0)    &#123;        x=1,y=0;        return a;    &#125;    int ret=exgcd(b,a%b,x,y);    int t=x;x=y,y=t-(a/b)*y;    return ret;&#125;int main()&#123;    cin&gt;&gt;b&gt;&gt;mod;    gcd=exgcd(b,mod,x,y);    if(gcd!=1)printf(&quot;not exist\n&quot;);    else printf(&quot;%d\n&quot;,(x%mod+mod)%mod);    return 0;&#125;/*来自 WJEMail大佬网址:https://www.cnblogs.com/NSDemail0820/p/9910344.html#_label2*/
这样我们求出逆元了
神奇！求形如ax+by=c的不定方程整数解和形如ax≡1（mod n）的同余方程

gcd (25,7)
(25,7)     (a,b)
(7,4)       (b,a-3b)
(4,3)       (a-3b,4b-a)
(3,1)       (4b-a,2a-7b)
(1,0)       (2a-7b,25b-7a)
——来自wweiyi的暑假培训

ax+by=c
也就是使用拓展欧几里得：

扩展欧几里德算法是用来在已知a, b求解一组x，y，使它们满足贝祖等式：
ax+by=gcd(a,b)=dax+by
= gcd(a, b) =d
ax+by=gcd(a,b)=d
（解一定存在，根据数论中的相关定理）。扩展欧几里德常用在求解模线性方程及方程组中。
——来自《百度百科》

有解的条件：gcd(a,b)|c
因此我们就可以解这样一个方程了!
代码如下
#include &lt;iostream&gt;using namespace std;int exgcd_x(int c,int d,int x1,int y1,int x2,int y2)&#123;	return d?exgcd_x(d,c%d,x2,y2,x1-(c/d)*x2,y1-(c/d)*y2):x1;&#125;int exgcd_y(int c,int d,int x1,int y1,int x2,int y2)&#123;	return d?exgcd_y(d,c%d,x2,y2,x1-(c/d)*x2,y1-(c/d)*y2):y1;&#125;int gcd(int c,int d)&#123;	return d?gcd(d,c%d):c;&#125;int main()&#123;	int a,b,n;	int x1=1,y1=0,x2=0,y2=1;	cin&gt;&gt;a&gt;&gt;b&gt;&gt;n;	if(n%gcd(a,b)!=0)	&#123;		cout&lt;&lt;&quot;No solution&quot;&lt;&lt;endl;		return 0;	&#125;	int x=exgcd_x(a,b,x1,y1,x2,y2);	int y=exgcd_y(a,b,x1,y1,x2,y2);	int g=n/gcd(a,b);	cout&lt;&lt;x*g&lt;&lt;&quot;a&quot;&lt;&lt;y*g&lt;&lt;&quot;b=&quot;&lt;&lt;n&lt;&lt;endl;	return 0;&#125;
ax≡1(mod n)
实际上就是求逆元！
这里就不再多说了!
总结：这个欧几里得算法和拓展欧几里得算法是很有用的算法，我们会很常用，因此我们要熟悉掌握这个算法，在OI竞赛中帮助我们，今天就到这里了
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>汉诺塔问题</title>
    <url>/2019/07/26/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[汉诺塔问题（Hanoi Tower Problem）
汉诺塔问题家喻户晓，它源于一个印度的神话，内容如下：
在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。
这个问题看起来十分可怕，实际上很简单。接下来就解决一个问题来体会这个小小问题中的大大的递归思想！

有三根柱子，第一根柱子上有n个从下向上越来越小的圆盘。


目标：使第一根柱子上的n个圆盘按原样摆放在另一个柱子上。


注：一次移动一个圆盘，不可以出现大的盘子在小的盘子上面的情况。

解：
首先我们先玩一下这个游戏。
接着我们找出一个规律，要彻底地把这个塔移开，我们必须要移开上方的n-1个盘子，使最下面的盘子可以移动到另一个柱子上，然后在把上方的n-1个盘子移动到最下
面的盘子（也就是最大的盘子）上就可以解决了。而n-1个盘子的移动方法也一样，因为最下面的大盘子对上面的n-1个盘子的移动毫无影响。
因此，我们可以得出一个递推式：
Fn=2Fn−1+1F_n=2F_{n-1}+1
Fn​=2Fn−1​+1
FnF_nFn​代表第一个柱子上有n个盘子的情况，所以这个问题得到了解决
代码如下：时间复杂度O(2n)O(2^n )O(2n)
#include &lt;iostream&gt;using namespace std;int main()&#123;	int n;	int f[20];	cin&gt;&gt;n;	f[1]=1;	for(int i=2;i&lt;=n;i++)	f[i]=2*f[i-1]+1;	cout&lt;&lt;f[n]&lt;&lt;endl;	return 0; &#125;
这个问题就简单地这么解决了。（瞎说，还有更简单的方法）
让我们来看一看输出结果：从n=1开始:1 3 7 15 31 63 127 255 511 1023 2047 4095 8191……
我们发现一个规律，所有的FnF_nFn​满足：
Fn=2n−1F_n=2^n-1
Fn​=2n−1
这才是最简单的方法！
有些人会说，这个方法是瞎猜的，只是凭运气而已，没事儿，我可以证明一下。
证：
数学归纳法。
当 n=1n=1n=1 时，F(n)=1,2n−1=1F(n)=1,2n-1=1F(n)=1,2n−1=1 ;命题显然成立
假设 n=kn=kn=k 时命题成立，即F(k)=2k−1F(k)=2k-1F(k)=2k−1；
当 n=k+1n=k+1n=k+1 时，F(k+1)=F(k)∗2+1F(k+1)=F(k)*2+1F(k+1)=F(k)∗2+1 ;
因为F(k)=2k−1F(k)=2^k-1F(k)=2k−1
所以
F(k+1)F(k+1)F(k+1)
=2F(k)+1=2F(k)+1=2F(k)+1
=(2k−1)∗2+1=(2^k-1)*2+1=(2k−1)∗2+1
=2k+1−1=2^{k+1}-1=2k+1−1
证毕。
所以这才是这种汉诺塔问题的最优解！
最终代码如下：时间复杂度O(⁡log2nlog_2nlog2​n )
#include &lt;iostream&gt;using namespace std;int qp(int a,int b)&#123;	if(b==0)	return 1;	int t=qp(a,b/2);	if(b%2==0)	return t*t;	else	return t*t*a;&#125;int main()&#123;	int n;	cin&gt;&gt;n;	cout&lt;&lt;qp(2,n)-1&lt;&lt;endl;	return 0;&#125;
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>简单素数筛</title>
    <url>/2019/07/29/%E7%AE%80%E5%8D%95%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
    <content><![CDATA[简单素数筛
今天，我看了一些数学知识，而数论是比较主要的，而素数筛是其中重要的一个，现在来介绍一下简单素数筛
首先来，普及一下素数的概念

若一个正整数无法被除了1和它本身之外的任何自然数整除，则称该数为素数，也称质数（或素数），否则称该正整数为合数。

通过介绍质数（下文统称质数）的概念，我们知道了一种判断质数的方法
通过枚举：这种方法的速度太慢了，因此我们需要更快的方法
ps：即使从1枚举到根号n也是很慢的
所以我们要引进一种好方法
就是大于二的所有数的倍数都是合数，那就好办了，我们可以从2开始（先初始化一个v[]数组的所有元素为零）2的倍数都是合数，标记v[i*j]为一,3的倍数都是合数，标记为1……
以此类推，我们就可以得出答案了
下面有一道例题

题目描述
给定一个范围N，你需要处理M个某数字是否为质数的询问（每个数字均在范围1-N内）
输入格式
第一行包含两个正整数N、M，分别表示查询的范围和查询的个数。
接下来M行每行包含一个不小于1且不大于N的整数，即询问该数是否为质数。
输出格式
输出包含M行，每行为Yes或No，即依次为每一个询问的结果。
输入输出样例
输入 #1
100 52349197
输出 #1
YesYesNoNoYes
说明/提示
时空限制：500ms 128M
数据规模：
对于100%的数据：N&lt;=10000，M&lt;=10000
样例说明：
N=100，说明接下来的询问数均不大于100且不小于1。
所以2、3、97为质数，4、91非质数。
故依次输出Yes、Yes、No、No、Yes。

这道题就是一道标准的筛素数的题，因为它要访问多个数啊，不做素数筛不可以啊，所以经过努力，我写出了代码
#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int v[10000005];//记录用int n,m;int p;void primes(int n)//简单素数筛函数&#123;	memset(v,0,sizeof(v));	for(int i=2;i&lt;=n;i++)	&#123;		if(v[i])		continue;		for(int j=i;j&lt;=n/i;j++)		v[i*j]=1; 	&#125;&#125;int main()&#123;	cin&gt;&gt;n&gt;&gt;m;	primes(n);//调用函数	for(int i=1;i&lt;=m;i++)	&#123;		cin&gt;&gt;p;		if(v[p])		cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;		else 		cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;	&#125;	return 0;&#125;
这就是简单素数筛，你get到了吗？
下集预告：高级素数筛（或其他的）
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>高级（线性）素数筛</title>
    <url>/2019/08/02/%E9%AB%98%E7%BA%A7%EF%BC%88%E7%BA%BF%E6%80%A7%EF%BC%89%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
    <content><![CDATA[高级（线性）素数筛
在不久前，我已经介绍了简单素数筛，所以我们这次来介绍一下高级素数筛，实际上就是线性筛素数，很快地能把素数筛出来，但是我们平常竞赛的时候常用的还是那个简单素数筛，所以我这篇文章就来普及一下加自我练习一下啦！
题目思路：
之前的简单素数筛中的合数会被多个数重复标记，因此造成了冗余，所以我们要想办法在这个方面优化，我们就想到了合数只要被它的最小质因子标记了一遍之后就不再标记了，这就减少了很大一部分的冗余，速度也就变快了。
大概过程如下：
1.从2~n之间枚举
2.如果v[i]=i,那么i就是质数
3.枚举小于等于v[i]的每个质数，让v[i*p]=p，在i的基础上在乘一个质因子p，得到一个新的数。
4.因为p&lt;=v[i]，所以p就是 合数i*p的最小质因子。



i
2
3
4
5
6
7
8
9
10




p&lt;=v[i]
2
2,3
2
2,3,5
2
2,3,5,7
2
2,3
2


i*p
4
6,9
8
10,15,25
12
14,21,35,49
16
18,.27
20



ps:以上表格来自《算法竞赛进阶指南》
因此我们就通过这种方法制作出了线性筛素数的程序
代码如下，时间复杂度
O(n)O(n)
O(n)
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn=10000005;int v[maxn],p[maxn];void primes(int n)&#123;	int m=0;	memset(v,0,sizeof(v));	for(int i=2;i&lt;=n;i++)	&#123;		if(v[i]==0)		&#123;			v[i]=i;			p[++m]=i;		&#125;		for(int j=1;j&lt;=m;j++)		&#123;			if(p[j]&gt;v[i]||p[j]&gt;(n/i))			break;			v[i*p[j]]=p[j];		&#125;	&#125;	for(int i=1;i&lt;=m;i++)	&#123;		cout&lt;&lt;p[i]&lt;&lt;endl;	&#125;&#125; int main()&#123;	int n;	cin&gt;&gt;n;	primes(n);	return 0;&#125;

接下来我们来一道例题练练手
题目：luogu P3383 【模板】线性筛素数
我帮大家复制了一下题面
题目描述
如题，给定一个范围N，你需要处理M个某数字是否为质数的询问（每个数字均在范围1-N内）
输入格式
第一行包含两个正整数N、M，分别表示查询的范围和查询的个数。
接下来M行每行包含一个不小于1且不大于N的整数，即询问该数是否为质数。
输出格式
输出包含M行，每行为Yes或No，即依次为每一个询问的结果。
输入输出样例
输入 #1
100 52349197
输出 #1
YesYesNoNoYes
说明/提示
时空限制：500ms 128M
数据规模：
对于30%的数据：N&lt;=10000，M&lt;=10000
对于100%的数据：N&lt;=10000000，M&lt;=100000
样例说明：
N=100，说明接下来的询问数均不大于100且不小于1。
所以2、3、97为质数，4、91非质数。
故依次输出Yes、Yes、No、No、Yes。

题目思路：这道题很简单，就是把刚才的代码稍加改动，判断一下只要v[i]==i，就是素数，否则就不是素数
代码如下
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn=10000005;int v[maxn],p[maxn];//v代表v是不是质数，是的话为1，p为质数void primes(int n)&#123;	int m=0;	memset(v,0,sizeof(v));	for(int i=2;i&lt;=n;i++)	&#123;		if(v[i]==0)		&#123;			v[i]=i;			p[++m]=i;		&#125;		for(int j=1;j&lt;=m;j++)		&#123;			if(p[j]&gt;v[i]||p[j]&gt;(n/i))			break;			v[i*p[j]]=p[j];		&#125;	&#125;&#125; int main()&#123;	int n,q,r;	cin&gt;&gt;n&gt;&gt;q;	primes(n);	for(int i=1;i&lt;=q;i++)	&#123;		cin&gt;&gt;r;		if(r==0||r==1)		&#123;			cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;			continue;		&#125;		if(v[r]==r)		cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;		else		cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;	&#125;	return 0;&#125;
下集预告:单源最短路径优化版或其他
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
</search>
